Вероятно, из школьного курса математики вы помните, что вектор — это направленный отрезок. На самом деле это только одно из возможных значений этого слова.

В программировании вектором называют одномерный проиндексированный набор данных, другими словами — одномерный массив.

→ На самом деле, между вектором из геометрии и вектором из программирования есть логическая связь. Вектор — это не просто какой-то абстрактный отрезок. По определению, вектор должен обладать длиной и направлением. Задать эти параметры можно с помощью набора координат, который сам по себе также называется вектором. В какой-то момент развития линейной алгебры связь между набором чисел в строке и вектором на чертеже стала практически исторической. Отсюда и пошло второе определение вектора как упорядоченного набора чисел.

==========Векторы в NumPy и арифметика==========
С векторами в NumPy можно производить арифметические операции: складывать, вычитать, умножать друг на друга, возводить один вектор в степень другого и т. д.

Операция, применённая к двум векторам, на самом деле применяется поэлементно. То есть при сложении двух векторов первым элементом нового вектора будет сумма первых элементов исходных векторов, вторым — сумма вторых элементов и т. д.

Произведём сложение двух векторов:

import numpy as np
vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
vec1 + vec2
# array([14. , 10. , 10.6, 15.5])

Что бы произошло при сложении двух списков? Их элементы просто объединились бы в один список:
list1 = [2, 4, 7, 2.5]
list2 = [12, 6, 3.6, 13]
list1 + list2
# [2, 4, 7, 2.5, 12, 6, 3.6, 13]

Чтобы сложить два этих списка поэлементно, нам пришлось бы написать списочное сокращение с применением функции zip():
[x + y for x, y in zip(list1, list2)]
# [14, 10, 10.6, 15.5]

Для совершения арифметических операций с векторами они должны быть одинаковой длины.

Поэлементно умножим два вектора одинаковой длины:

vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
vec1 * vec2
# array([24. , 24. , 25.2, 32.5])

А теперь создадим vec2, который будет на один элемент короче, чем vec1:
vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6])
vec1 * vec2
# ValueError: operands could not be broadcast together with shapes (4,) (3,)
# Ошибка значения: операнд не может быть распространён одновременно на структуры с формами (4,) и (3,).

Возникла ValueError.

Исключением является случай, когда операция происходит с вектором и одним числом. Например, вектор целиком можно умножить на число или возвести в степень этого числа:

vec = np.arange(5)
vec * 10
# array([ 0, 10, 20, 30, 40])
vec ** 2
# array([ 0,  1,  4,  9, 16])

Также векторы можно сравнивать друг с другом поэлементно:
vec1 = np.array([2, 4, 7, 2.5])
vec2 = np.array([12, 6, 3.6, 13])
vec1 > vec2
# array([False, False,  True, False])

В результате получаем вектор исходной длины из булевых переменных, которые соответствуют результату поэлементного сравнения чисел из двух векторов.
Аналогично можно сравнивать вектор с числом:
vec = np.array([14,15,9,26,53,5,89])
vec <= 26
# array([ True,  True,  True,  True, False,  True, False])


==========Продвинутые операции с векторами==========
В курсе алгебры проходят в том числе следующие действия с векторами: вычисление длины (нормы) вектора, нахождение расстояния между векторами, вычисление скалярного произведения. Некоторые из них очень часто используются в машинном обучении, алгоритмах кластеризации и построении математических моделей. Как специалистам в Data Science вам предстоит с этим работать.

Длина вектора, то есть расстояние между его началом и концом, [в евклидовом пространстве] вычисляется как квадратный корень из суммы квадратов всех его координат.

Посчитаем длину следующего вектора:
vec = np.array([3, 4])

Для начала воспользуемся формулой: возведём все элементы в квадрат, посчитаем их сумму, а затем найдём квадратный корень. Найдите все перечисленные операции в данном коде:
length = np.sqrt(np.sum(vec ** 2))
print(length)
# 5.0

Но можно было поступить проще. В NumPy есть специальный подмодуль linalg, который позволяет производить операции из линейной алгебры.
Для вычисления длины вектора нам потребуется функция norm:
length = np.linalg.norm(vec)
print(length)
# 5.0
Мы получили то же самое расстояние с помощью одного действия!

Расстояние между двумя векторами, то есть расстояние между их концами, [в евклидовом пространстве] вычисляется как квадратный корень из суммы квадратов разностей соответствующих координат. 
→ По сути, расстояние между векторами — это длина такого вектора, который является разностью этих векторов. В самом деле, при вычитании двух векторов вычитаются их соответствующие координаты.

Реализуем вычисление расстояния в коде. Сначала — «сложным» способом напрямую из формулы:
vec1 = np.array([0, 3, 5])
vec2 = np.array([12, 4, 7])
distance = np.sqrt(np.sum((vec1 - vec2) ** 2))
distance
# 12.206555615733702

А теперь применим более простой способ — используем уже известную нам функцию np.linalg.norm:
vec1 = np.array([0, 3, 5])
vec2 = np.array([12, 4, 7])
distance = np.linalg.norm(vec1 - vec2)
distance
# 12.206555615733702

Наконец, скалярным произведением двух векторов называют сумму произведений их соответствующих координат.

Откуда такое странное название? Слово «скаляр» — синоним слова «число». То есть результатом вычисления скалярного произведения векторов является число — скаляр. Дело в том, что существуют и другие произведения векторов, не все из которых дают на выходе число.

Реализуем это в коде (по-английски скалярное произведение называют dot — точечный — или scalar product, отсюда и такое название переменной):
vec1 = np.arange(1, 6)
vec2 = np.linspace(10, 20, 5)
scalar_product = np.sum(vec1 * vec2)
scalar_product
# 250.0

Наверное, вы уже догадались, что в NumPy есть множество встроенных функций, поэтому возник резонный вопрос: можно ли проще и вообще без формул?
Да! Для этого используют функцию np.dot(x, y):
scalar_product = np.dot(vec1, vec2)
scalar_product
# 250.0

Скалярное произведение также имеет широкое применение в математике и других операциях с векторами. В частности, равенство скалярного произведения нулю означает перпендикулярность рассматриваемых векторов:
x = np.array([25, 0])
y = np.array([0, 10])
np.dot(x, y)
# 0

Здесь были специально заданы векторы, параллельные осям х и у (так как одна из координат в них равна нулю). Они перпендикулярны, как перпендикулярны соответствующие оси, а скалярное произведение действительно равно нулю.

В целом, скалярное произведение часто используется для определения угла между векторами.

Зачем это может пригодиться специалисту в Data Science?
→ Вам ещё обязательно предстоит работать с векторами не только при изучении теории линейной алгебры, но и при освоении машинного обучения на практике. Например, есть специальные преобразования, которые позволяют превратить слова в тексте в числовые векторы. Затем с помощью определения направлений полученных векторов можно находить слова-синонимы и антонимы, а также оценивать общую эмоциональную окраску текста. Такие алгоритмы для анализа данных используются, чтобы автоматически по отзывам определять степень удовлетворённости клиентов продуктом.


==========Базовые статистические функции для векторов==========
Функции np.min и np.max позволяют находить максимальное и минимальное значение в векторе. Их можно записывать как в виде np.min(<vector>), так и в виде <vector>.min():
vec = np.array([2,7,18,28,18,1,8,4])
vec.min()
# 1
np.max(vec)
# 28

Функция mean позволяет посчитать среднее значение. Больше не требуется реализовывать её «руками»!
vec.mean()
# 10.75