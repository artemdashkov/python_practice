==========КЛАСС DataFame==========
Основа библиотеки Pandas — класс DataFrame, предназначенный для эффективной обработки табличных данных (то есть данных, разбитых по столбцам). В частности, в нём есть средства именования столбцов, а также поддерживается гибкая индексация записей, как в таблицах реляционных баз данных или электронных таблицах, например MS Excel.

Класс DataFrame изначально предназначен для работы с индексированными и размеченными данными, напоминающими таблицы реляционных баз данных или рабочие листы Excel. Вспомним, как создаётся объект DataFrame.
import pandas as pd

df = pd.DataFrame([10, 26, 30, 40])
df.columns = ['Целые']
df.index = ['a', 'b', 'c', 'd']
print(df)

   Целые
a     10
b     26
c     30
d     40

В этом простом примере продемонстрированы основные возможности хранения данных в объектах DataFrame:
- данные могут быть какого угодно типа (list, tuple, ndarray и др.);
- данные группируются в столбцы, которым присваиваются имена (подписи);
- данные снабжаются индексами, которые могут иметь разный формат (числа, строки, дата/время и т. п.).

Работать с объектом DataFrame удобнее и эффективнее, чем с обычным объектом ndarray, который накладывает немало ограничений, когда нужно, к примеру, увеличить существующий массив. С точки зрения производительности вычислений возможности этих двух классов примерно сопоставимы.

Ниже приведено несколько примеров выполнения типичных операций с объектом DataFrame:
print(df.index)
# Index(['a', 'b', 'c', 'd'], dtype='object')

print(df.columns)
# Index(['Целые'], dtype='object')

print(df.loc['c'])
# Целые    30
# Name: c, dtype: int64

print(df.loc[['a', 'd']])
   Целые
a     10
d     40

print(df.iloc[1:3])
   Целые
b     26
c     30

Pandas позволяет применять функции к объекту DataFrame:
print(df.sum())
Целые    106
dtype: int64

print(df.apply(lambda x: x **2))
   Целые
a    100
b    676
c    900
d   1600

Чтобы создать независимую копию, необходимо выполнить «глубокое» копирование:
df_copy = df.copy(deep = True)

В отличие от массивов ndarray, объект DataFrame можно увеличивать по любым измерениям:
df = pd.DataFrame([10, 26, 30, 40])
df.columns = ['Целые']
df.index = ['a', 'b', 'c', 'd']
df['Вещественные'] = (1.5, 2.5, 3.5, 4.5)
print(df)

   Целые  Вещественные
a     10           1.5
b     26           2.5
c     30           3.5
d     40           4.5


В качестве источника данных для столбца может использоваться другой объект DataFrame. В подобных случаях индексы согласуются автоматически: 
df = pd.DataFrame([10, 26, 30, 40])
df.columns = ['Целые']
df.index = ['a', 'b', 'c', 'd']
df['Вещественные'] = (1.5, 2.5, 3.5, 4.5)
df["Имена"] = pd.DataFrame(['Иван', 'Степан', 'Баба Валя', 'Гермоген'], index=['d', 'a', 'b', 'c'])
print(df)

   Целые  Вещественные      Имена
a     10           1.5     Степан
b     26           2.5  Баба Валя
c     30           3.5   Гермоген
d     40           4.5       Иван

Похожим образом работает операция присоединения данных. Запись добавляемых строк может подаваться в виде словаря. Однако следует опасаться неприятного побочного эффекта — замены исходных индексов числовым диапазоном.
df = pd.DataFrame([10, 26, 30, 40])
df.columns = ['Целые']
df.index = ['a', 'b', 'c', 'd']
df['Вещественные'] = (1.5, 2.5, 3.5, 4.5)
df["Имена"] = pd.DataFrame(['Иван', 'Степан', 'Баба Валя', 'Гермоген'], index=['d', 'a', 'b', 'c'])
df._append({"Целые": 100, "Имена": "Виталик"}, ignore_index = True)
print(df)

   Целые  Вещественные      Имена
a     10           1.5     Степан
b     26           2.5  Баба Валя
c     30           3.5   Гермоген
d     40           4.5       Иван

Для сохранения исходных индексов целесообразно создать объект, совпадающий по структуре с исходным объектом DataFrame:

df = pd.DataFrame([10, 26, 30, 40])
df.columns = ['Целые']
df.index = ['a', 'b', 'c', 'd']
df['Вещественные'] = (1.5, 2.5, 3.5, 4.5)
df["Имена"] = pd.DataFrame(['Иван', 'Степан', 'Баба Валя', 'Гермоген'], index=['d', 'a', 'b', 'c'])
df = df._append(pd.DataFrame({"Целые":100, "Вещественные":5.75, "Имена":"Виталик"}, index=['y',]))
print(df)

   Целые  Вещественные      Имена
a     10          1.50     Степан
b     26          2.50  Баба Валя
c     30          3.50   Гермоген
d     40          4.50       Иван
y    100          5.75    Виталик

Несмотря на появление пустых значений, методы объекта DataFrame по-прежнему работают — строки со значениями NaN игнорируются.

Чтобы удалить столбцы, можно использовать метод .drop():
df = pd.DataFrame([10, 26, 30, 40])
df.columns = ['Целые']
df.index = ['a', 'b', 'c', 'd']
df['Вещественные'] = (1.5, 2.5, 3.5, 4.5)
df["Имена"] = pd.DataFrame(['Иван', 'Степан', 'Баба Валя', 'Гермоген'], index=['d', 'a', 'b', 'c'])
df = df._append(pd.DataFrame({"Целые":100, "Вещественные":5.75, "Имена":"Виталик"}, index=['y',]))
df = df.drop(["Целые", "Вещественные"], axis= 1)

print(df)

       Имена
a     Степан
b  Баба Валя
c   Гермоген
d       Иван
y    Виталик

Чтобы удалить строки, метод .drop() также подойдёт:
df = df.drop(["b"], axis= 0)
print(df)

   Целые  Вещественные     Имена
a     10          1.50    Степан
c     30          3.50  Гермоген
d     40          4.50      Иван
y    100          5.75   Виталик

==========Расширенные возможности класса DataFrame==========
Ниже рассматривается пример, в котором используется объект ndarray, содержащий массив случайных чисел с нормальным распределением. Это позволит нам исследовать дополнительные возможности библиотеки Pandas, в частности, функцию Datetimelndex(), предназначенную для обработки временных рядов. Заполним массив 10 х 5 случайными величинами:
import numpy as np
arr = np.random.standard_normal((10, 5))

Объект DataFrame можно создавать на основе объекта ndarray. Такое решение удобно, поскольку структура исходного массива не меняется, к нему лишь добавляется метаинформация (индексы): 
df = pd.DataFrame(arr)

Параметры, передаваемые функции DataFrame():

ПАРАМЕТР	ФОРМАТ		ОПИСАНИЕ

data		ndarray/dict/DataFrame	Данные для объекта DataFrame. Объект dict может включать объекты Series, ndarray и list

index		Index/массив	Список индексов; по умолчанию — range(n)

columns		Index/массив	Список имён столбцов; по умолчанию — range(n)

dtype		dtype, по умолчанию None	Тип данных столбцов; по умолчанию подбирается автоматически

copy		bool, по умолчанию None	Флаг копирования данных из источника

Термином «массив» здесь обозначается структура, подобная объекту ndarray, например список. Index — это экземпляр класса Index библиотеки Pandas.

Как было показано выше, имена столбцов объекта DataFrame можно напрямую задать в виде списка, содержащего нужное число элементов. Другими словами, задавать или менять атрибуты объекта DataFrame совсем несложно.
# df.columns = ['A', 'B', 'C', 'D', 'E']
# print(df)

# print(df["B"].mean())
-0.0725630283320162

Для эффективной работы с временными рядами необходимо иметь возможность использовать значения даты/времени в качестве индексов. В библиотеке Pandas эта задача решается очень легко. Предположим, что в нашей таблице, состоящей из десяти строк и пяти столбцов, записи соответствуют датам конца месяца начиная с января 2022 года. Соответствующий объект Datetimeindex генерируется с помощью метода date_range().
dates = pd.date_range("2022-1-1", periods=10, freq="M")
print(dates)

# DatetimeIndex(['2022-01-31', '2022-02-28', '2022-03-31', '2022-04-30',
               '2022-05-31', '2022-06-30', '2022-07-31', '2022-08-31',
               '2022-09-30', '2022-10-31'],
              dtype='datetime64[ns]', freq='M')
			  
Параметры метода date_range():
ПАРАМЕТР	ФОРМАТ				ОПИСАНИЕ
start		string/datetime		Начальная дата диапазона
end			string/datetime		Конечная дата диапазона
periods		integer/None		Количество периодов (если параметр start или end равен None)
freq		string/DateOffset	Строка, задающая длину периода (например, 5D означает 5 дней)
tz			string/None			Название часового пояса в случае локализованного индекса
normalize	bool, по умолчанию None		Флаг нормализации дат start и end, чтобы отсчёт шёл с полуночи
name		string, по умолчанию None	Название создаваемого индекса

В следующем примере только что созданный объект Datetimeindex применяется к имеющемуся массиву:
arr = np.random.standard_normal((10, 5))
df = pd.DataFrame(arr)
df.columns = ['A', 'B', 'C', 'D', 'E']
dates = pd.date_range("2022-1-1", periods=10, freq="M")
df.index = dates
print(df)

                   A         B         C         D         E
2022-01-31 -1.098321  0.240933  0.316244  0.502024  0.776742
2022-02-28 -0.197807  1.501297 -0.222663 -0.400736 -0.062297
2022-03-31  0.659706 -1.714578  0.085287 -1.749957  0.072196
2022-04-30 -0.582541  2.022645 -0.108832 -0.417113 -0.559301
2022-05-31 -0.916673 -1.476968  1.319830 -0.766606 -0.759592
2022-06-30 -1.362799 -2.020037 -0.671640 -0.333653  0.347490
2022-07-31  0.241757 -0.340012 -0.539286  0.639914  0.702626
2022-08-31  0.579171 -0.377528 -0.311604 -1.112944 -0.458583
2022-09-30  1.563816  0.165508  0.751160  1.122080  0.032956
2022-10-31 -1.131597 -0.159663  0.245357 -0.069348  0.833670


При создании объектов Datetimeindex с помощью метода date_range() можно использовать различные значения аргумента freq:
ЕДИНИЦА ИЗМЕРЕНИЯ	ОПИСАНИЕ
B			Банковский день
C			Назначаемый банковский день (экспериментальная возможность)
D			Календарный день
W			Неделя
M			Конец месяца
BM			Конец финансового месяца
MS			Начало месяца
BMS			Начало финансового месяца
Q			Конец квартала
BQ			Конец финансового квартала
QS			Начало квартала
BQS			Начало финансового квартала
A			Конец года
BA			Конец финансового года
AS			Начало года
BAS			Начало финансового года
H			Час
T			Минута
S			Секунда
L			Миллисекунда
U			Микросекунда


==========Базовая аналитика данных в Pandas==========
Подобно классу ndarray в NumPy, класс DataFrame библиотеки Pandas содержит множество удобных методов. Для начала рассмотрим методы info() и describe().
print(df.info())

<class 'pandas.core.frame.DataFrame'>
DatetimeIndex: 10 entries, 2022-01-31 to 2022-10-31
Freq: M
Data columns (total 5 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   A       10 non-null     float64
 1   B       10 non-null     float64
 2   C       10 non-null     float64
 3   D       10 non-null     float64
 4   E       10 non-null     float64
dtypes: float64(5)
memory usage: 480.0 bytes
None

print(df.describe())
               A          B          C          D          E
count  10.000000  10.000000  10.000000  10.000000  10.000000
mean    0.496845  -0.203521   0.371093  -0.299812  -0.075579
std     0.864815   0.917925   1.083135   0.587455   0.940622
min    -1.276083  -2.051866  -0.950891  -1.162111  -1.493596
25%     0.065161  -0.766930  -0.773080  -0.707841  -0.769916
50%     0.629878  -0.060602   0.775009  -0.189601   0.031439
75%     1.043303   0.393468   1.091313  -0.071394   0.255708
max     1.802625   1.027966   1.919766   0.946265   1.348930

Кроме того, можно легко вычислить сумму, среднее и накопительную сумму как по столбцам, так и по строкам.

print(df.sum())
A   -1.505766
B    0.912361
C    3.164486
D    6.455271
E    5.984400
dtype: float64


print(df.mean())
A   -0.181681
B   -0.244934
C    0.043167
D   -0.177080
E   -0.399292
dtype: float64


print(df.mean(axis=1))
2022-01-31   -0.371724
2022-02-28   -0.403142
2022-03-31    0.475343
2022-04-30    0.079370
2022-05-31   -0.552434
2022-06-30   -0.109527
2022-07-31    0.312075
2022-08-31   -0.556609
2022-09-30   -0.352784
2022-10-31    0.085725
Freq: M, dtype: float64


print(df.cumsum())
                   A         B         C         D         E
2022-01-31  0.144546  0.706206  0.126885  1.032567 -0.912483
2022-02-28  0.274426  0.002962  0.517442  1.784131 -0.188164
2022-03-31  0.136975 -0.201234  0.751884  1.048487 -0.244194
2022-04-30  0.539374 -0.563097 -0.159212  2.067066  0.478598
2022-05-31  0.395458 -1.786000  1.532672  3.062033  1.982255
2022-06-30  0.399466 -2.334312  1.481811  2.676258  3.308970
2022-07-31  0.696753 -2.456745  1.602821  1.353361  3.567785
2022-08-31  0.693220 -1.182646  0.356050  0.398695  3.883744
2022-09-30  0.791527 -1.109713  0.328094  0.284554  3.195762
2022-10-31  1.128964 -0.517487 -0.273298 -0.059167  1.274605

========Полезные статистические функции объектов DataFrame:========
.mean(skipna = True)	Возвращает среднюю величину для каждого столбца, пропуск NaN (по умолчанию True)
.median(skipna = True)	Возвращает медиану для каждого столбца, пропуск NaN (по умолчанию True)
.mode(dropna = True)	Возвращает медиану для каждого столбца, пропуск NaN
.var()					Возвращает дисперсию
.std()					Возвращает стандартное отклонение
.diff()					Возвращает абсолютную разность индексируемых значений
.unique()				Возвращает список уникальных значений
.value_counts()			Подсчитывает количество каждого уникального значения
.describe()				Даёт расширенное описание


К объектам DataFrame также можно применять универсальные функции NumPy.
print(np.mean(df, axis=0))
A    0.230729
B    0.079214
C   -0.688801
D    0.188284
E   -0.027923
dtype: float64

print(np.sqrt(abs(df)))
                   A         B         C         D         E
2022-01-31  1.392623  0.665854  0.900621  0.811218  1.117200
2022-02-28  1.310642  1.108560  0.695871  0.892307  0.356646
2022-03-31  0.746950  0.367565  1.273247  0.738462  0.706315
2022-04-30  0.694018  1.268515  1.155940  0.827326  0.533858
2022-05-31  0.369888  0.536059  0.869679  1.162644  1.183488
2022-06-30  1.136636  0.797560  1.397929  0.613093  0.511732
2022-07-31  0.658126  0.253992  0.590639  1.372327  0.427609
2022-08-31  1.220339  0.937421  0.152710  1.062396  1.296784
2022-09-30  0.762774  0.890550  1.199808  0.847819  0.446358
2022-10-31  1.016358  0.802116  1.092952  0.309006  1.226673

print(np.sqrt(abs(df)).sum())
A     8.721728
B    10.950044
C     8.751277
D    10.395544
E     7.370753
dtype: float64

print(100*df + 100)
                     A           B           C           D           E
2022-01-31  187.351174   41.833213  239.543522  182.800010  148.501336
2022-02-28   35.607486  156.259219  123.745183  168.247456   21.455487
2022-03-31   99.044456  117.060193  123.955989  194.675284   16.424718
2022-04-30  289.975872  226.461194   73.282351   66.493617   82.196221
2022-05-31  204.451353  187.870832  139.906871  -58.309877   20.594297
2022-06-30   62.929256   78.300132   80.626266  175.004092  254.920337
2022-07-31  122.381294  251.219303  113.666784  183.915964   70.934848
2022-08-31  233.840229  145.993537  106.664337   34.750421  -44.169013
2022-09-30   77.496450   86.568089  165.733714  118.910154    5.391804
2022-10-31  -30.564513  248.482313  154.000501  281.765861  -49.191361

Таким образом, к объекту DataFrame можно применить те же самые универсальные функции NumPy, что и к объекту ndarray, содержащему аналогичные данные.

Библиотека Pandas достаточно терпима к ошибкам в том смысле, что она самостоятельно перехватывает их, вставляя в результирующую таблицу значение NaN, если соответствующую математическую операцию невозможно выполнить. Более того, во многих случаях с полученной таблицей можно работать так, как если бы она была полной. Это очень удобно, ведь на практике неполные наборы данных встречаются чаще, чем хотелось бы.

==========КЛАСС Series==========
Помимо класса DataFrame, в библиотеке Pandas имеется другой важный класс: Series. Он применяется для хранения данных, представленных единственным столбцом. В этом смысле класс Series можно рассматривать как частный случай класса DataFrame. Объект Series будет получен при выборе отдельного столбца из табличной структуры объекта DataFrame.

import pandas as pd
import numpy as np

S = pd.Series(np.linspace(0, 15, 7), name="series")
print(S, type(S))

0     0.0
1     2.5
2     5.0
3     7.5
4    10.0
5    12.5
6    15.0
Name: series, dtype: float64 <class 'pandas.core.series.Series'>

s = df["A"]
print(s, type(s))

2022-01-31    0.274298
2022-02-28    1.196468
2022-03-31    0.777888
2022-04-30    1.700994
2022-05-31    0.406222
2022-06-30    1.634507
2022-07-31   -0.289606
2022-08-31    2.535805
2022-09-30    1.671560
2022-10-31   -1.680018
Freq: M, Name: A, dtype: float64 <class 'pandas.core.series.Series'>

Все основные методы объекта DataFrame применимы и к объекту Series. В качестве иллюстрации рассмотрим применение метода mean():
print(s.mean(), S.mean())
-0.08064113186483499 7.5

==========Фильтрация данных==========
Чаще всего данные извлекаются согласно условиям, накладываемым на значения столбцов. В качестве примера рассмотрим следующий набор данных:
data = np.random.standard_normal((10, 2))
df = pd.DataFrame(data, columns=["x", "y"])
print(df.info())

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 10 entries, 0 to 9
Data columns (total 2 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   x       10 non-null     float64
 1   y       10 non-null     float64
dtypes: float64(2)
memory usage: 292.0 bytes
None


print(df.head())
          x         y
0  0.104025  0.026573
1 -0.605075 -0.231698
2 -1.511205 -0.730415
3 -0.304394  1.082579
4 -0.297843 -0.054424

print(df.tail())
          x         y
5  1.362326 -1.172701
6 -0.152286 -0.739356
7  0.450880  1.460968
8 -1.969637  0.206641
9 -0.636826  1.587738

В следующем примере показано, как применять логические операции и операции сравнения к значениям двух столбцов:
print(df['x']>0.5)

0    False
1    False
2    False
3    False
4    False
5     True
6    False
7    False
8    False
9     True
Name: x, dtype: bool

print((df['x']>0) | (df["y"]<0))
0     True
1     True
2     True
3     True
4    False
5     True
6     True
7     True
8     True
9     True
dtype: bool

print((df['x']>0) & (df["y"]<0))
0     True
1     True
2    False
3    False
4    False
5    False
6    False
7     True
8    False
9     True
dtype: bool

Полученные в предыдущем примере объекты Series с булевыми значениями удобно использовать в качестве критериев отбора данных. Альтернативным решением будет извлечение данных с помощью метода query(), в котором критерий отбора задаётся в виде строки:
print(df[df["x"]>0])

          x         y
1  2.576348  0.058311
3  0.684295  3.383547
5  2.083893 -0.927497
7  0.889843 -1.105540
9  0.312522  0.494714

print(df.query("x>0"))
          x         y
6  0.349180  0.893521
8  0.636588 -0.872648

print(df[(df["x"] > 0) & (df["y"] > 0)])
          x         y
0  1.715425  0.490362
2  0.135850  0.863052
9  0.598920  0.255667

print(df.query("x > 0 & y > 0"))
          x         y
0  0.415242  1.429945
8  0.260945  2.088087

Операторы сравнения могут также применяться сразу ко всему объекту DataFrame:
print(df>0)
       x      y
0   True  False
1   True  False
2  False   True
3   True  False
4   True   True
5   True   True
6  False   True
7  False  False
8  False  False
9   True  False

print(df[df>0])
          x         y
0  0.433376       NaN
1       NaN  0.072424
2  0.199558       NaN
3  1.161181  0.021883
4       NaN  0.389449
5       NaN  0.406358
6  0.586125       NaN
7  0.241179       NaN
8       NaN       NaN
9       NaN       NaN

Иногда необходимо выделить для анализа фрагмент исходного набора данных DataFrame. Pandas в этом случае работает очень просто: необходимо указать в квадратных скобках при имени DataFrame объект для отображения, который может определяться логическим условием, как это было рассмотрено ранее, либо прямым указанием на объект (.columns[], .loc[]):
arr = np.random.standard_normal((6,4))
df = pd.DataFrame(arr, columns=["A", "B", "C", "D"],
                  index=[1,2,3,4,5,6])
print(df[df.columns[1:3]])

          B         C
1  0.699310  0.008595
2 -0.878470 -0.574164
3 -2.595997 -1.123993
4  1.593370 -0.070910
5  0.111281  1.119296
6  0.412927  1.754716

print(df.loc[2:5,["B", "D"]])
          B         D
2 -0.578880  0.392458
3 -0.339454  0.818348
4 -0.087488 -0.454010
5 -0.508467  0.937974