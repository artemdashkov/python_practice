- [Install](#install)
- [Теория](#теория)
    - [Какие бывают типы данных](#какие-бывают-типы-данных)
    - [Аннотация типов](#Аннотация-типов)
    - [Итератор](#итератор)
    - [Генератор](#генератор)
        - [yield](#yield)
    - [Тернарный оператор](#тернарный-оператор)
    - [Лямбда функция](#лямбда-функция)
    - [Декоратор](#декоратор)
- [Modules](#modules)
	- [black](#black)
	- [flake8](#flake8)
	- [os](#os)
    - [pip](#pip)
- [Работа с виртуальным окружением](#работа-с-виртуальным-окружением)
- [allure](#allure)
- [assert](#assert)
- [random](#random)
- [Встроенные функции](#встроенные-функции)
    - [in](#in)
    - [filter](#filter)
    - [map](#map)
    - [min, max, sum](#min-max-sum)
    - [sorted](#sorted)
    - [range](#range)
    - [pickle](#pickle)
- [классы](#классы)
	- [Наследование](#наследование)
    - [Инкапсуляция](#инкапсуляция)
	- [Полиморфизм](#полиморфизм)
    - [Абстракция](#абстракция)
	    - [@abstractmethod](#abstractmethod)
	- [@dataclass](#dataclass)
	- [@staticmethod](#staticmethod)

# Install
```python
apt install python3 # Установка Python в linux
```

```python
#!/usr/bin/python3  -строка в файле линукс, которая позволяет интерпретировать файл как python файл
```
# Теория
## Какие бывают типы данных
В Python существует несколько основных типов данных, каждый из которых обладает своими особенностями и применяется в разных ситуациях. 
1. Числовые типы (Numeric types):
    - int — целые числа (например, 1, 2, -5).
    - float — числа с плавающей запятой (например, 3.14, -0.001).
    - complex — комплексные числа (например, 1 + 2j).
2. Строки (String):
    - str — это последовательность символов, заключенная в одинарные или двойные кавычки (например, "hello", 'world').
3. Логический тип (Boolean):
    - bool — принимает значения True или False.
4. Списки (List):
    - list — упорядоченные, изменяемые коллекции, которые могут содержать элементы разных типов (например, [1, 2, 3], ['apple', 'banana']).
5. Кортежи (Tuple):
    - tuple — упорядоченные, неизменяемые коллекции, которые также могут содержать элементы разных типов (например, (1, 2, 3), ('apple', 'banana')).
6. Множества (Set):
    - set — неупорядоченные коллекции уникальных элементов (например, {1, 2, 3})
7. Словари (Dictionary):
    - dict — Неупорядоченные коллекции пар “ключ-значение”, где ключи должны быть уникальными (например, {'name': 'Alice', 'age': 25}).
8. NoneType:
    - None — специальный тип, представляющий отсутствие значения или null.

## Аннотация типов
Аннотация типов в Python позволяет разработчикам указывать типы переменных, аргументов функций и возвращаемых значений, что улучшает читаемость кода и помогает инструментам статического анализа выявлять ошибки. Аннотации типов в Python не влияют на выполнение программы, но они помогают улучшить документацию и интеграцию с инструментами разработки. 

Вот пример использования аннотаций типов:
```python
def add(a: int, b: int) -> int | None:  
    return a + b  

result = add(5, 3)  
print(result)  # Вывод: 8
```
**Пояснение примера:**
- `a: int и b: int` — это аннотации типов для аргументов функции add, указывающие, что оба аргумента должны быть целыми числами.
- `-> int | None` — аннотация типа для возвращаемого значения, указывающая, что функция возвращает целое число или None (что может означать отсутствие результата или ошибку).

**Другие примеры:**

Список строк
```python
from typing import List  

def join_strings(strings: List[str]) -> str:  
    return ', '.join(strings)  

result = join_strings(['hello', 'world'])  
print(result)  # Вывод: hello, world  
```

Использование типов для словарей
```python
from typing import Dict  

def get_age(name: str, ages: Dict[str, int]) -> int:  
    return ages.get(name, 0)  

ages = {'Alice': 30, 'Bob': 25}  
print(get_age('Alice', ages))  # Вывод: 30  
```

## Итератор
**Итерируемые объекты** — это объекты, которые могут быть перебраны. Примеры: списки (list), кортежи (tuple), множества (set), словари (dict) и строки (str). Они поддерживают метод `__iter__()`, который возвращает итератор.

**Итератор в Python** — это объект, который позволяет перебирать элементы коллекции (например, списка, кортежа, множества или словаря) по одному за раз. Итератор предоставляет доступ к элементам и "запоминает" свое текущее состояние. Например, он помнит, на каком элементе он остановился. Итераторы реализуют два метода:
- `__iter__()` — возвращает сам итератор. Он может возвращать объект, который имплементирует метод `__next__()`. Обычно для итерируемых объектов этот метод просто возвращает `self`.
- `__next__()` — возвращает следующий элемент последовательности из итератора. Когда элементы заканчиваются, он вызывает исключение `StopIteration`. Чтобы избежать этого, можно передать второй аргумент, который будет возвращен в случае исчерпания итератора.

**Использование встроенных итераторов**
Итерируемые объекты (такие как списки, кортежи или строки) могут создавать итераторы с помощью функции iter(). Например:

```python
my_list = [1, 2, 3]  
iterator = iter(my_list)  

print(next(iterator))  # Вывод: 1  
print(next(iterator))  # Вывод: 2  
print(next(iterator))  # Вывод: 3  
# next(iterator) вызовет StopIteration, так как элементы закончились 
print(next(iterator, "Конец"))
```

**Итерация через for-цикл**

Наиболее распространенный способ перебора элементов — это использование цикла for, который автоматически управляет итерацией и обработкой исключения StopIteration:
```python
for item in my_list:  
    print(item)  
```
Пример реализации собственного итератора. Вот пример, как создать свой собственный итератор, который перебирает числа от 1 до N:
```python
class MyIterator:  
    def __init__(self, n):  
        self.n = n  
        self.current = 1  # Начальное значение  

    def __iter__(self):  
        return self  # Возвращаем сам итератор  

    def __next__(self):  
        if self.current > self.n:  
            raise StopIteration  # Если достигли конца, выбрасываем исключение  
        else:  
            current_value = self.current  
            self.current += 1  # Увеличиваем текущее значение на 1  
            return current_value  # Возвращаем текущее значение  

# Использование итератора  
for num in MyIterator(5):  
    print(num)  

>>> 1  
>>> 2
>>> 3  
>>> 4  
>>> 5  
```

## Генератор
Генератор в Python — это специальный тип итератора, который позволяет создавать последовательности значений. Он позволяет вам генерировать значения "на лету", что экономит память, так как не нужно хранить всю последовательность в памяти сразу.

Генераторы создаются с помощью функций, использующих yield вместо return. Когда функция с yield вызывается, она возвращает объект-генератор и при этом сохраняет своё состояние, позволяя возобновить выполнение функции с того места, где она была остановлена.

```python
def count_up_to(max):  
    count = 1  
    while count <= max:  
        yield count  
        count += 1

for number in count_up_to(5):  
    print(number)  
```
Этот код выведет числа от 1 до 5. Генераторы полезны для работы с большими объемами данных, когда нужно генерировать данные по мере их необходимости, а не держать их все в памяти.

1. Генерация последовательностей
Генераторы могут использоваться для создания простых последовательностей. Например, вот генератор, который создаёт последовательность квадратов чисел:
```python
def square_numbers(n):  
    for i in range(n):  
        yield i ** 2  

# Пример использования  
for square in square_numbers(5):  
    print(square)  
```

2. Генераторы для работы с файлами
Генераторы удобны для построчной обработки файлов, что позволяет обрабатывать большие файлы, не загружая их целиком в память:
```python
def read_file_line_by_line(file_path):  
    with open(file_path) as file:  
        for line in file:  
            yield line.strip()  # Удаляем символы новой строки  

# Пример использования  
for line in read_file_line_by_line('example.txt'):  
    print(line)  
```

3. Фильтрация данных
Генераторы можно использовать для фильтрации данных. Допустим, у вас есть список чисел, и вы хотите оставить только четные:
```python
def even_numbers(numbers):  
    for number in numbers:  
        if number % 2 == 0:  
            yield number  

# Пример использования  
numbers = range(10)  
for even in even_numbers(numbers):  
    print(even)  
```

4. Генераторы в комбинации с expressions (групповая генерация)
Генераторы можно создавать с помощью выражений-генераторов, которые выглядят как списковые включения, но используют круглые скобки:
```python
# Генератор, создающий кубы от 0 до 9  
cubes = (x ** 3 for x in range(10))  

# Пример использования  
for cube in cubes:  
    print(cube)  
```

5. Генерация бесконечной последовательности
Генераторы также могут использоваться для создания бесконечных последовательностей. Например, следующий генератор будет бесконечно генерировать числа Фибоначчи:
```python
def fibonacci():  
    a, b = 0, 1  
    while True:  
        yield a  
        a, b = b, a + b  

# Пример использования: печатаем первые 10 чисел Фибоначчи  
fib = fibonacci()  
for _ in range(10):  
    print(next(fib))  
```

6. Генерация данных на основе условий
Генераторы могут также использоваться с условиями для создания более сложных последовательностей. Например, можно создать генератор для получения первых N чисел, которые делятся на 3 и 5:
```python
def multiples_of_3_and_5(n):  
    count = 0  
    num = 0  
    while count < n:  
        if num % 3 == 0 and num % 5 == 0:  
            yield num  
            count += 1  
        num += 1  

# Пример использования  
for number in multiples_of_3_and_5(5):  
    print(number)  
```

### yield
`yield` в Python — это ключевое слово, которое используется в определении функций для преобразования обычной функции в генератор. Генераторы позволяют итерироваться по последовательности значений, не создавая сразу все значения в памяти, что особенно полезно при работе с большими наборами данных или бесконечными последовательностями. В контексте автоматизации и фикстуры это разделитель между предусловий и пост условий.

Основные моменты о yield:
1. Генерация значений: Когда функция содержит оператор yield, она возвращает генератор, который можно использовать в цикле for или в любом месте, где требуется итерация.
2. Состояние функции: Функция, содержащая yield, при каждом вызове оператора yield сохраняет свое состояние (локальные переменные и текущее значение) и продолжает выполнение с этого места при следующем вызове.
3. Экономия памяти: Генераторы позволяют сэкономить память, поскольку значения создаются по мере необходимости, а не хранятся в памяти.
```python
def count_up_to(n):  
    count = 1  
    while count <= n:  
        yield count  
        count += 1  

# Использование генератора  
for number in count_up_to(5):  
    print(number)
1  
2  
3  
4  
5    
```


## Тернарный оператор
В Python тернарный оператор реализуется с помощью конструкции, известной как "условное выражение". Синтаксис выглядит следующим образом:
`значение_если_истина if условие else значение_если_ложь`
```python
age = 18  
can_vote = "Да, может голосовать" if age >= 18 else "Нет, не может голосовать"  
print(can_vote)  # Выведет: Да, может голосовать
```
Здесь, если age больше или равен 18, переменной can_vote присваивается строка "Да, может голосовать". В противном случае — строка "Нет, не может голосовать".

## Лямбда функция
Лямбда-функция в Python — это анонимная функция, которая определяется с помощью ключевого слова lambda. Она может принимать любое количество аргументов, но может содержать только одно выражение. Лямбда-функции обычно используются для создания небольших функциональных объектов без необходимости явно определять обычную функцию с использованием def.

Синтаксис лямбда-функции выглядит следующим образом:
```python
lambda аргументы: выражение

# Лямбда-функция для сложения двух чисел  
add = lambda x, y: x + y  

# Использование функции  
result = add(2, 3)  # result будет 5  
print(result)  
```
Лямбда-функции часто применяются в таких местах, как:
- В аргументах функций высшего порядка, например, map(), filter(), и sorted()
- В качестве простых обратных вызовов в GUI и других библиотеках.
```python
# Использование в filter для фильтрации четных чисел  
numbers = [1, 2, 3, 4, 5]  
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]  
```

## Декоратор
Декоратор в Python — это специальная конструкция, позволяющая изменять или расширять поведение функции или метода без изменения их исходного кода. Это достигается с помощью функции, которая принимает другую функцию в качестве аргумента и возвращает новую функцию, обычно с добавленным функционалом.

Пример простого декоратора:
```python
def my_decorator(func):  
    def wrapper():  
        print("Перед вызовом функции.")  
        func()  
        print("После вызова функции.")  
    return wrapper  

@my_decorator  
def say_hello():  
    print("Привет!")  

say_hello()

>>> Перед вызовом функции.  
>>> Привет!  
>>> После вызова функции.  
```
Как это работает:
1. Определение декоратора: my_decorator определяет вложенную функцию wrapper, которая добавляет дополнительные действия до и после вызова оригинальной функции func.
2. Использование: С помощью @my_decorator мы "оборачиваем" функцию say_hello, что означает, что при вызове say_hello() фактически будет вызвана функция wrapper.

Декораторы часто используются для:
1. Логирования (Logging)
2. Проверки прав доступа (Authorization)
3. Кэширования (Caching)
4. Измерения времени выполнения функции (Timing)

# Modules
## black
black - форматтер, позволяет выполнять автоматическое редактирование кода
```python
pip install black # запуска форматтера
black 
```
## flake8
```python
pip install flake8 # установка линтера flake8 для программ на Python с открытыми исходными кодами, позволяет находить ошибки в стиле оформления кода
flake8 programm.py # применить линтер к выбранному файлу
flake8 project_folder # применить линтер к всему проекту
```

## id
В Python, чтобы увидеть адрес ячейки памяти, в которой хранится переменная, можно использовать встроенную функцию id(). Эта функция возвращает уникальный идентификатор объекта, который, в большинстве реализаций Python, соответствует адресу памяти объекта.
```python
a_1 = [1, 2]
a_2 = [1, 2]
id(a_1)
>>> 1899355888896

id(a_2)
>>> 1899355886784

b_1 = 3
b_2 = 3

id(b_1)
>>> 140718421375480

id(b_2)
>>> 140718421375480
```

## os
```python
import os
print(os.getcwd()) # получить путь к папке, где находится текущий файл
> C:\Users\admin\PycharmProjects\selenium\lesson_10

print(f'{os.getcwd()}\\downloads')
> C:\Users\admin\PycharmProjects\selenium\lesson_10\downloads
```
- `os.mkdir('./dir_1')` - создает папку в месте размещению исполняемого файла
- `os.mkdir('./dir_2./dir_3')` - создает папку dir_2 в которой будет размещена папка dir_3, выдаст исключение "FileExistsError" если папка уже создана
- `os.environ` - возвращает в виде словаря переменные окружения

## type()
Функция `type()` в Python используется для получения типа объекта. Она возвращает класс, к которому принадлежит переданный объект. С помощью `type()` можно узнать, является ли объект строкой, числом, списком, словарем и так далее. Функция `type()` полезна для отладки и проверки типов данных в программе.
```python
num = 10  
print(type(num))  # <class 'int'>  

text = "Hello, world!"  
print(type(text))  # <class 'str'>  

lst = [1, 2, 3]  
print(type(lst))  # <class 'list'>  
```
Иногда `type()` можно использовать для проверки, является ли объект экземпляром определенного класса, с помощью `isinstance()`:
```python
print(isinstance(num, int))  # True  
print(isinstance(text, str))  # True  
```

# Versions
```python
python --version # показывает версию python
python3 --version # показывает версию python
```

# chmod a+x <имя скрипта>
	-сделать файл испольняемым для всех пользователей
	
Запуска скрипта python
ИЗ ТОЙ ДИРЕКТОРИИ, ГДЕ НАХОДИТСЯ ФАЙЛ СКРИПТА
	# ./<имя скрипта>	-С указанием интерпретатора в начале скрипта
	# /usr/bin/python3 <имя скрипта>	-Без указания интерпретатора в начале скрипта

ИЗ ДРУГОЙ ДИРЕКТОРИИ, ГДЕ НЕТ ФАЙЛА СКРИПТА
	# <полный путь к файлу скрипта>	-С указанием интерпретатора в начале скрипта
	# /usr/bin/python3 <полный путь к файлу скрипта>	-Без указания интерпретатора в начале скрипта

## pip
 - система управления пакетами или менеджера пакетов (Python Package Index)
```python
apt install python3-pip # установка pip в линуксе
pip3 --version	# проверить версию pip
pip install -r requirements.txt		# установка зависимостей
pip freeze	# просмотр зависимостей
pip freeze > requirements.txt	# все зависимости скопировать в файл requirements.txt
pip install pip-review  # Обновить всех пакетов в окружении
pip3 list -перечень всех установленных библиотек
```

#### pip3 команда опции пакет(ы)
	show		показать информацию о пакете
	search		найти пакет
	install		установить пакет
	uninstall	удалить пакет
	download	скачать пакет и зависимости (без установки)
	list		вывести список установленных пакетов


	

# poetry
Установка Windows (Powershell)
	официальная документация https://python-poetry.org/docs/#installing-with-the-official-installer
	в powershell: (Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -
	pip install poetry
	
poetry --version
	Poetry (version 1.7.1)

poetry config --list
	перечень настроек poetry

Установка зависимостей
	poetry install 	# для первичной установки
	poetry update 	# для обновления
	
poetry show --tree
	показать зависимости
	
poetry shell
	создать и активировать виртуальное окружение одной командой
	

# РАБОТА С ВИРТУАЛЬНЫМ ОКРУЖЕНИЕМ
apt install python3-venv
	-(команда линукс)установка пакета venv

python3 -m venv myenv
или
python -m venv myenv
	-создать новое окружение, где myenv имя вирутального окружения. После выполнения команды будет создана папка с именем myenv, содержащая все необходимые файлы для виртуального окружения.

python -m venv virt_name

pip install virtualenv
	установка virtualenv, требуется для python	


bin include lib lib64 pyvenv.cfg share
	-посмотреть содержимое виртуального окружения

source myenv/bin/activate
	-активация виртуального окружения. где myenv название папки среды

после активации виртуального окружения в командную строку будет добавлено имя виртуального окружения.


(myenv) user@host:~$ pip install requests
	-Эта команда установит пакет requests только в текущем виртуальном окружении.

deactivate
	-используется для удаления виртуальной среды

exit()

# allure
```python
$ pip install allure-pytest
$ py.test --alluredir=%allure_result_folder% ./tests
$ allure serve %allure_result_folder%
https://pypi.org/project/allure-pytest/
```
# Трехместное выражение if/else в Python

```python
if a < b:
    rez = a + b
else:
    rez = a - b

# общий вид if/else в одну строку
x = a if condition else b

# Выражение примера выше будет выглядеть следующим образом
rez = a + b if a < b else a - b.
```

# assert

```python
assert True, 'Print message'
> 

assert False, 'Print message'
> # assert False, 'Print message', AssertionError: Print message
```

**При выявлении несоответствии в методе assert дальнейший код не выполняется, а при положительном assert - дальнейший код выполняется, например**:
- Assert завершился AssertionError 
```python
value_1 = 3
value_2 = 5
assert value_1 == value_2, "Not equal"
print('this is code after assert method')

>>>
Traceback (most recent call last):
  File "C:\Users\dashkov\PycharmProjects\selenium_stepik_2\lesson_18\draft_3.py", line 4, in <module>
    assert value_1 == value_2, "Not equal"
AssertionError: Not equal
```

- Assert завершился без ошибок
```python
value_1 = 3
value_2 = 3
assert value_1 == value_2, "Not equal"
print('this is code after assert method')

>>>
this is code after assert method
```
# Встроенные функции
## in
- `in` - Возвращает True если последовательность присутствует в объекте
- `not in` - Возвращает True если последовательность не присутствует в объекте
```python
ur_1 = "yandex.ru/slash_1/slash_2"
ur_2 = "yandex.ru"

print (ur_2 in ur_1)
> True
print (ur_2 not in ur_1)
> False

print (ur_1 in ur_2)
> False
print (ur_1 not in ur_2)
> True
```
Вхождение/наличие элемента в список/ кортеж/ множество
```python
>>> x = [1, 2, 3, 4, 5, 6, 7, 8]
>>> 5 in x
# True

>>> 5 not in x
# False

>>> 0 in x
# False

>>> 0 not in x
# True
```

## filter
Функция filter() в Python используется для фильтрации итерируемых объектов (таких как списки, кортежи и т.д.) по заданному условию. Она принимает два аргумента: функцию и итерируемый объект. Возвращает итератор, содержащий элементы, для которых функция вернула True.
```python
# Синтаксиc
filter(function, iterable)
```
- `function`: Функция, которая определяет условие фильтрации. Если функция возвращает True, элемент будет включен в результат; если False, элемент будет исключён.
- `iterable`: Итерируемый объект, который вы хотите отфильтровать.
Пример:
```python
# Определяем список чисел  
numbers = [1, 2, 3, 4, 5, 6]  

# Функция, которая проверяет четность  
def is_even(num):  
    return num % 2 == 0  

# Используем filter для фильтрации четных чисел  
even_numbers = filter(is_even, numbers)  

# Преобразуем результат в список  
even_numbers_list = list(even_numbers)  

print(even_numbers_list)  # Вывод: [2, 4, 6]  
```

## map
Функция `map` в Python — это встроенная функция, которая позволяет применять заданную функцию к каждому элементу переданной последовательности (например, к списку, кортежу или строке) и возвращать итератор, содержащий результаты применения функции.
- `map` возвращает итератор, поэтому для получения результата нужно преобразовать его в список или другую коллекцию, если требуется.
- Функция может быть любой callable, включая встроенные функции, пользовательские функции и лямбда-функции.
- Если передано несколько итерируемых объектов, функции, применяемой через `map`, должны быть 1:1 соответствия по количеству аргументов.

Функция `map` удобна для функционального программирования, часто используется для обработки данных и упрощает код, избегая необходимости в явных циклах.

Синтаксис
```python
map(function, iterable, ...)  
```
- **function**: функция, которая будет применена к каждому элементу. Это может быть как встроенная функция, так и пользовательская функция.
- **iterable**: одна или несколько последовательностей, к элементам которых будет применяться функция. Если передано несколько последовательностей, функция должна принимать такое же количество аргументов, сколько последовательностей.

`map` возвращает итератор, который можно преобразовать в другие структуры данных (например, в список или кортеж).

Примеры использования
1. Применение функции к каждому элементу списка:
```python
def square(x):  
    return x * x  

numbers = [1, 2, 3, 4, 5]  
squared_numbers = map(square, numbers)  

# Преобразуем в список  
print(list(squared_numbers))  # Вывод: [1, 4, 9, 16, 25]  
```
2. Использование лямбда-функции:
```python
numbers = [1, 2, 3, 4, 5]  
squared_numbers = map(lambda x: x * x, numbers)  

print(list(squared_numbers))  # Вывод: [1, 4, 9, 16, 25] 
```
3. Применение функции к нескольким итераторам:
```python
def add(x, y):  
    return x + y  

a = [1, 2, 3]  
b = [4, 5, 6]  
sum_ab = map(add, a, b)  

print(list(sum_ab))  # Вывод: [5, 7, 9]  
```

## min, max, sum
1. min()
Функция min() возвращает наименьшее значение среди переданных аргументов. Она может работать с несколькими аргументами или с последовательностью (например, списком).
```python
# С несколькими аргументами  
print(min(3, 5, 2, 8))  # Вывод: 2  

# С последовательностью  
numbers = [3, 5, 2, 8]  
print(min(numbers))  # Вывод: 2  
```
2. max()
Функция max() работает аналогично функции min(), но возвращает наибольшее значение.
```python
# С несколькими аргументами  
print(max(3, 5, 2, 8))  # Вывод: 8  

# С последовательностью  
numbers = [3, 5, 2, 8]  
print(max(numbers))  # Вывод: 8  
```

3. sum()
Функция sum() возвращает сумму элементов в последовательности. По умолчанию она принимает второй аргумент, который добавляется к сумме (по умолчанию равен 0).
```python
# Список чисел  
numbers = [1, 2, 3, 4, 5]  
print(sum(numbers))  # Вывод: 15  

# С добавлением начального значения  
print(sum(numbers, 10))  # Вывод: 25 (15 + 10)  
```

## sorted
В Python функция sorted() используется для сортировки итерируемых объектов, таких как списки, кортежи и строки. Эта функция returns a new sorted list from the elements of any iterable. 
- sorted() не изменяет оригинальный список — он возвращает новый отсортированный список.
- Если вы хотите отсортировать список "на месте", можно использовать метод sort(), который вызывается для списков.

```python
sorted(iterable, key=None, reverse=False)  
```
- iterable: объект, который нужно отсортировать (например, список, кортеж).
- key: (необязательный) функция, которая извлекает ключ для сравнения элементов (по умолчанию используется сам элемент).
- reverse: (необязательный) если True, сортировка будет в обратном порядке.

1. Сортировка списка чисел:
```python
numbers = [5, 2, 9, 1, 5, 6]  
sorted_numbers = sorted(numbers)  
print(sorted_numbers)  # Вывод: [1, 2, 5, 5, 6, 9]
```

2. Сортировка строк:
```python
words = ["banana", "apple", "cherry"]  
sorted_words = sorted(words)  
print(sorted_words)  # Вывод: ['apple', 'banana', 'cherry']  
```

3. Сортировка в обратном порядке:
```python
sorted_numbers_desc = sorted(numbers, reverse=True)  
print(sorted_numbers_desc)  # Вывод: [9, 6, 5, 5, 2, 1] 
```

4. Использование параметра key:
key позволяет определить функцию, которая будет применена к каждому элементу перед сравнением. Это дает возможность сортировать элементы не по их значению, а по какому-то другому критерию.
- Может принимать любую функцию: Вы можете использовать как встроенные функции, так и функции, определенные вами. Например, если у вас есть список строк, и вы хотите отсортировать их по длине, вы можете использовать функцию `len`.
- Возвращаемое значение функции: Функция, переданная в key, должна возвращать значение, по которому будет производиться сортировка. Это значение должно быть сравнимым (то есть у него должно быть определено поведение для операций сравнения).
```python
# Сортировка списка по длине строк  
words = ["banana", "pear", "apple", "cherry"]  
sorted_by_length = sorted(words, key=len)  
print(sorted_by_length)  # Вывод: ['pear', 'apple', 'banana', 'cherry']
```

```python
# Сортировка списка кортежей по второму элементу  
data = [(1, 'one'), (3, 'three'), (2, 'two'), (4, "four"), (5, "fife"), (6, "six")]
sorted_data = sorted(data, key=lambda x: x[1])  
print(sorted_data)  # Вывод: [(5, 'fife'), (4, 'four'), (1, 'one'), (6, 'six'), (3, 'three'), (2, 'two')]
```

5. Сортировка словаря по ключам:
```python
data = {'b': 1, 'a': 2, 'c': 3}  
sorted_keys = sorted(data)  
print(sorted_keys)  # Вывод: ['a', 'b', 'c']  
```



## range
Функция `range()` генерирует последовательность чисел. Чаще всего функция `range()` используется для создания списков либо в циклах.

```python
# Использование в циклах:
for x in range(5):
    print(x)
>>>
0
1
2
3
4
```

```python
# Базовое использование range
a_1 = range(5) # при указании одного числа последовательность начинается с 0 
a_2 = list(a_1) 

print(a_1)		> range(0, 5)
print(a_2)		> [0, 1, 2, 3, 4]
```
```python
#  Указание начального значения
a_1 = range(1, 5)
a_2 = list(a_1)

print(a_1)
print(a_2)
>>> range(1, 5)
>>> [1, 2, 3, 4]
```

```python
# Указание шага
c_1 = range(0, 50, 10)
c_2 = list(c_1)

print(c_1)		> range(0, 50, 10)
print(c_2)		> [0, 10, 20, 30, 40]
```

```python
# Отрицательный шаг
a_1 = range(10, 0, -1)
a_2 = list(a_1)

print(a_1)		range(10, 0, -1)
print(a_2)		[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```


## pickle
```python
import os
import pickle

# синтаксис pickle.dump: что, куда и операции
pickle.dump(
    driver.get_cookies(),
    open(os.getcwd()+"/cookies/cookies.pkl", "wb"))

# синтаксис pickle.load: что загружем, откудакуда и операции
cookies = pickle.load(open(os.getcwd()+"/cookies/cookies.pkl", "rb"))
```

Операции pickle:
- wb - write binary: записать в бинарном формате
- rb - read binary: считать из  бинарного формата

## random

### random.randint и random.randrange
```python
import random

""" Функции randint и randrange возвращают целое число. """
number = random.randint(1, 10) # вернет значение от 1 до 10, оба значения включены в диапазон
number = random.randrange(10) # вернет значение от 0 до 9
number = random.randrange(5,10) # вернет значение от 5 до 9
number = random.randrange(1, 102, 10) # вернет одно значение из списка [1, 11, 21, 31, 41, 51, 61, 71, 81, 91, 101]
```

### random.random
```python
""" Функции random возвращает случайное число с плавающей точкой."""
number = random.random() # возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 (но исключая 1.0)
```

### random.uniform
```python
""" Функции uniform тоже возвращает случайное число с плавающей точкой,  но при этом она позволяет задавать диапазон значений, из которого следует отбирать значения. """
number = random.uniform(1.0, 10.0) # возвращает случайное число с плавающей точкой в диапазоне от 1.0 до 10.0
```

### random.choices
```python
""" Функции choices возвращает список из n повторяющихся элементов."""
a = random.sample([1, 2, 3, 4, 5, 6, 7], k=3)
print(a)

> [3, 1, 3]
```

### random.sample
```python
""" Функции sample возвращает список из n не повторяющихся элементов."""
a = random.sample([1, 2, 3, 4, 5, 6, 7], 2)
print(a)

> [3, 1]
```

### random.seed 
"random seed" используется для инициализации генератора случайных чисел, что позволяет воспроизводить одинаковые случайные последовательности. Seed (семя) — это начальное число, которое используется генератором случайных чисел для создания последовательности случайных чисел. Если вы начинаете с одного и того же семени, вы получите одинаковую последовательность случайных чисел каждый раз.
```python
import random  

# Установим семя  
random.seed(10)  

# Теперь генерируем случайные числа  
print(random.randint(1, 100))  # Например, это может вывести 73  
print(random.randint(1, 100))  # Это может вывести 43
```
Если вы снова запустите этот код с тем же семенем (10), вы снова получите 73 и 43. Если вы измените семя:
```python
random.seed(20)  
print(random.randint(1, 100))  # Теперь это может быть, например, 56  
print(random.randint(1, 100))  # И это может быть 61  
```
- **Воспроизводимость:** Используя одно и то же семя, вы всегда получаете одни и те же случайные числа, что полезно для тестирования.
- **По умолчанию:** Если вы не устанавливаете семя, Python будет использовать текущее время или другое случайное значение, так что последовательность каждый раз будет разной.
- **При тренировках и исследованиях:** Это часто используется в научных исследованиях и алгоритмах машинного обучения, когда вам нужно контролировать вариации в ваших экспериментах.

# Классы
ООП - подход в программировании, основанной на создании объектов, которые содержат атрибуты данных и методы для работы с этими данными.

`Класс в Python` — это шаблон для создания объектов, который объединяет данные (атрибуты) и функции (методы), которые работают с этими данными. Классы позволяют создавать новые типы данных, инкапсулируя логику и состояние. Классы являются основой объектно-ориентированного программирования (ООП) в Python.

`Объект (Экземпляр класса)` - это программная сущность, которая создается на основе класса и содержит данные и методы. В концептуальном плане объект представляет собой автономную единицу, которая состоит из атрибутов данных и методов, которые оперируют атрибутами данных. 
`Атрибуты данных` - находящиеся внутри объекта данные 
`Методы` - Выполняемые объектом функции, которые выполняют операции с атрибутами данных.
`Инкапсуляция` - объединение данных и программного кода в одном объекте.

Принципы ООП в python:
1. Наследование
2. Инкапсуляция
3. Полиморфизм
4. Абстракция

## Наследование
Наследование - возможность создания нового класса на основе уже существующего, наследуя его свойства и методы. Это способствует повторному использованию кода и упрощает его поддержку.

Вот основные моменты о наследовании классов в Python:
1. Создание базового класса: Это класс, от которого будут наследоваться другие классы.
2. Создание производного класса: Это класс, который наследует свойства и методы базового класса.

```python
# Определяем базовый класс  
class Animal:  
    def __init__(self, name):  
        self.name = name  

    def speak(self):  
        return "Animal sound"  

# Определяем производный класс  
class Dog(Animal):  
    def speak(self):  
        return "Bark"  

class Cat(Animal):  
    def speak(self):  
        return "Meow"

class Cow(Animal):
    def __init__(self, name, weight):
        Animal.__init__(self, name)  # super().__init__(name)
        self.weight = weight
    def speak(self):
        return "Moo"

class 

# Создаем экземпляры производных классов  
dog = Dog("Rex")  
cat = Cat("Mittens") 
cow = Cow("Marta", 300)

# Вызываем метод speak  
print(dog.name + " says: " + dog.speak())  # Rex says: Bark  
print(cat.name + " says: " + cat.speak())  # Mittens says: Meow 
print(cow.name + " says: " + cow.speak(), "and weight is: " + str(cow.weight)  # Marta says: Moo and weight is: 300
```
### Особенности при наследовании классов 
1. Ключевое слово `super()`: Используется для вызова методов базового класса.
```python
class Dog(Animal):  
    def __init__(self, name, breed):  
        super().__init__(name)  # Вызов конструктора базового класса  
        self.breed = breed  
```
2. Множественное наследование: Класс может наследовать от нескольких классов.
```python
class Canine:  
    def bark(self):  
        return "Woof!"  

class Pet:  
    def play(self):  
        return "Playing!"  

class Dog(Canine, Pet):  
    pass 
```
3. Переопределение методов: Метод в производном классе может переопределять метод базового класса.
4. Абстрактные классы: Используются для создания интерфейсов. Для этого используется модуль abc.
```python
from abc import ABC, abstractmethod  

class Animal(ABC):  
    @abstractmethod  
    def speak(self):  
        pass  

class Dog(Animal):  
    def speak(self):  
        return "Bark"  
```

## Инкапсуляция
`Инкапсуляция` — скрытие внутренней реализации класса и предоставление только необходимых интерфейсов для взаимодействия с его объектами. Это помогает защитить внутренние данные и методы от некорректного использования, а также упрощает изменения и улучшает читаемость кода.

## Полиморфизм
Полиморфизм — Возможность использования одного и того же интерфейса для различных типов объектов. В Python полиморфизм достигается с помощью методов, которые могут иметь одинаковые имена, но разные реализации в разных классах.

Основные типы полиморфизма в Python:
- Полиморфизм через наследование: Когда дочерние классы переопределяют методы родительского класса.
- Полиморфизм через интерфейсы: Когда разные классы реализуют один и тот же метод, но ведут себя по-разному.

**Пример полиморфизма через наследование**
```python
class Animal:  
    def speak(self):  
        raise NotImplementedError("Subclasses must implement this method")  

class Dog(Animal):  
    def speak(self):  
        return "Woof!"  

class Cat(Animal):  
    def speak(self):  
        return "Meow!"  

def animal_sound(animal):  
    print(animal.speak())  

# Примеры использования  
dog = Dog()  
cat = Cat()  

animal_sound(dog)  # Вывод: Woof!  
animal_sound(cat)  # Вывод: Meow!  
```
Объяснение примера:
- В классе `Animal` определён метод `speak`, который должен быть переопределён в дочерних классах. Он вызывает ошибку, если вызывается в самом классе Animal.
- Классы `Dog` и `Cat` наследуют от `Animal` и предоставляют свою реализацию метода speak.
- Функция `animal_sound` принимает объект типа `Animal` и вызывает его метод `speak`. Благодаря полиморфизму, можно передавать объекты разных классов (`Dog` и `Cat`) и получать правильный звук.

**Пример полиморфизма через интерфейсы**
```python
class Bird:  
    def fly(self):  
        return "I'm flying!"  

class Airplane:  
    def fly(self):  
        return "Flying through the sky!"  

def fly_object(flyable):  
    print(flyable.fly())  

# Примеры использования  
sparrow = Bird()  
boeing = Airplane()  

fly_object(sparrow)  # Вывод: I'm flying!  
fly_object(boeing)   # Вывод: Flying through the sky!  
```
**Объяснение примера:**
- Класс `Bird` и класс `Airplane` оба имеют метод `fly()`.
- Функция `fly_object` принимает объект, имеющий метод `fly`, и вызывает этот метод. Таким образом, можно использовать любые объекты, которые реализуют этот метод, независимо от их внутренней структуры.

Таким образом, полиморфизм позволяет разработчикам писать более абстрактный и гибкий код, обеспечивая возможность для расширения и изменения, не влияя на существующий код.

## Абстракция
Абстракция в объектно-ориентированном программировании (ООП) в Python — это принцип, который позволяет скрыть сложные детали реализации и предоставить только необходимые интерфейсы для взаимодействия с объектами. Она помогает сосредоточиться на том, что делает объект, а не на том, как он это делает.

### @abstractmethod
Абстрактные классы в Python позволяют создавать базовые классы с определенными методами, которые должны быть реализованы в производных классах. Это полезно для определения интерфейса, который обязаны соблюдать подклассы. Для работы с абстрактными классами в Python используется модуль abc.

**Основные элементы абстрактных классов**
1. Модуль abc: Импортирует необходимые декораторы и классы для создания абстрактных классов.
2. Декоратор @abstractmethod: Используется для определения абстрактного метода, который должен быть реализован в производных классах.

```python
from abc import ABC, abstractmethod  

# Определяем абстрактный класс  
class Animal(ABC):  

    @abstractmethod  
    def speak(self):  
        pass  # Абстрактный метод без реализации  

    @abstractmethod  
    def move(self):  
        pass  # Другой абстрактный метод  

# Определяем производный класс  
class Dog(Animal):  
    
    def speak(self):  
        return "Bark"  

    def move(self):  
        return "Run"  

# Еще один производный класс  
class Bird(Animal):  

    def speak(self):  
        return "Tweet"  

    def move(self):  
        return "Fly"  

# Создаем экземпляры производных классов  
dog = Dog()  
bird = Bird()  

# Вызываем методы  
print(dog.speak())  # Output: Bark  
print(dog.move())   # Output: Run  
print(bird.speak()) # Output: Tweet  
print(bird.move())  # Output: Fly 
```
**Особенности абстрактных классов**
1. Невозможность создания экземпляра: Нельзя создать экземпляр абстрактного класса напрямую. Например, animal = Animal() вызовет ошибку TypeError.
2. Наследование: Продуктовые классы должны реализовывать все абстрактные методы базового класса, иначе они также станут абстрактными.
3. Дополнительные методы: Абстрактный класс может иметь и обычные методы с реализацией.

**Заключение**

Абстрактные классы являются мощным инструментом для обеспечения соблюдения интерфейсов в иерархиях классов. Они способствуют созданию более структурированного, поддерживаемого и понятного кода. Использование абстрактных классов помогает определить, какие методы должны быть реализованы в производных классах, что делает код более предсказуемым и удобным для понимания.

## @dataclass
```python
from dataclasses import dataclass 

@dataclass
class Card:
    summary: str = None
    owner: str = None
    state: str = "todo"
    id: int = field(default=None, compare=False)

    @classmethod
    def from_dict(cls, d):
        return Card(**d)
    def to_dict(self):
        return asdict(self)
```


## @staticmethod
`@staticmethod` в Python — это декоратор, который используется для определения статического метода внутри класса. 
Статический метод не требует доступа к экземпляру класса (то есть объекту, созданному из этого класса) или к самому классу. 
Он может быть вызван как через сам класс, так и через экземпляры класса.

Вот основные особенности статических методов:
1. Нет доступа к `self` и `cls`: Поскольку статический метод не привязан ни к экземпляру, ни к классу, он не принимает автоматически аргументы self (для экземпляра) или cls (для класса).
2. Пользовательские функции: Статические методы могут использоваться для того, чтобы группировать функции, которые логически относятся к классу, даже если они не работают с его экземплярами или атрибутами класса.
3. Вызов: Их можно вызывать как через экземпляр класса, так и через сам класс.

Пример использования:
```python
class MyClass:  
    @staticmethod
    def my_static_method(x, y):  
        return x + y  

# Вызов статического метода через класс  
result1 = MyClass.my_static_method(5, 3)  
print(result1)  # Вывод: 8  

# Вызов статического метода через экземпляр класса  
obj = MyClass()  
result2 = obj.my_static_method(10, 20)  
print(result2)  # Вывод: 30  
```

Пример использования из проекта:
```python
class Common:

	@staticmethod
	def skip_if_eng_lang_and_fca_license(cur_language, cur_country):
		if cur_country == "gb" and cur_language == "":
			pytest.skip("Current test case not available for the Eng language and FCA license")
```


## Втроенные свойства
- `__dict__` - возвращает словарь, в котором все свойства класса или объекта.
- `Point.type_pt = "disc"` - добавление нового свойства `type_pt` со значением `disc` для класса. для всех объектов также появится это свойство.
- `setattr(Point, 'prop', 1)` - добавление нового свойства `prop` со значением `1` для класса. если же прописать уже существующий атрибут, то он будет переопределен: `setattr(Point, 'prop', 2)`
- `getattr(Point, 'a')` - если в классе нет атрибута а, то вызывет ошибку
- `getattr(Point, 'a', False)` - если в классе нет атрибута а, то вызывет False
- `getattr(Point, 'color')` - вернет "black"
- `hesattr(Point, 'prop')` - если такого атрибута нет, то вернет False, если атрибут существует то вернет True
- `delattr(Point, 'type_pt')` - удаляет атрибут из класса, если вызывем для несуществующего атрибута то появится ошибка 

## Магические методы
- `__init__(self)` - инициализатор объекта класса, вызывается сразу после создания экземпляра класса
- `__del__(self)` - финилизатор класса, вызывается непосредственно перед его удалением


# with, as

Конструкция with ... as в Python используется для работы с контекстными менеджерами, 
что позволяет управлять ресурсами, обеспечивая их правильное открытие и закрытие.
Это особенно полезно при работе с файлами, сетевыми соединениями и другими ресурсами, 
требующими очистки (например, освобождения памяти или закрытия файлов).

Конструкция with ... as упрощает работу с ресурсами, 
обеспечивает их автоматическое управление и позволяет избежать утечек ресурсов, 
что делает ваш код более чистым и безопасным.

Когда вы используете конструкцию with, она гарантирует правильное выполнение действий 
при входе и выходе из блока кода, даже если в нем возникает ошибка. 
Основными преимуществами являются:
- Автоматическое управление ресурсами.
- Упрощение синтаксиса и улучшение читаемости кода.

```python
with open('example.txt', 'w') as file:  
    file.write('Привет, мир!')  
```
1. open('example.txt', 'w'): Функция open открывает файл example.txt в режиме записи.
2. as file: Открытый файл присваивается переменной file, и теперь мы можем использовать её для записи в файл.
3. with: Когда блок кода завершен (либо нормально, либо с исключением), файл автоматически закрывается, что устраняет необходимость явно вызывать file.close().

# @contextmanager
В Python @contextmanager — это декоратор из модуля contextlib, который позволяет создавать контекстные менеджеры без необходимости реализовывать методы __enter__ и __exit__ в классе. Контекстные менеджеры используются в конструкции with для автоматического управления ресурсами, такими как файлы или сетевые соединения, обеспечивая их корректное открытие и закрытие.

Когда вы используете @contextmanager, вы можете определить yield в функции, что позволяет разделить код на две части: до yield и после. Код до yield выполняется при входе в контекст, а код после yield выполняется при выходе из контекста, что позволяет обрабатывать освобождение ресурсов.

Вот пример использования @contextmanager:
```python
 print("Entering the context")  
 try:  
 yield42 # Значение, которое будет возвращено в блоке with finally:  
 print("Exiting the context")  

# Используем контекстный менеджерwith my_context_manager() as value:  
 print(f"Inside the context: {value}")  
```

Вывод будет следующим:
```python
Entering the contextInside the context:42Exiting the context```  

В этом примере при входе в контекст выполняется код перед `yield`, при выходе — код после `yield`. Это удобно для управления ресурсами и обеспечения их правильного освобождения.  
```

пример
```python
@contextmanager
def cards_db():
    db_path = get_path()
    db = cards.CardsDB(db_path)
    yield db
    db.close()
```

`list_1 = [1, 2, 3, 4, 5]`

`list_1[::-1]`      `[5, 4, 3, 2, 1]`