- [Install](#install)
- [Теория](#теория)
    - [Какие бывают типы данных](#какие-бывают-типы-данных)
        - [Списки](#списки)
            - [Срезы](#срезы)
        - [Строки](#Строки)
        - [Словари](#Словари)
        - [Кортежи](#Кортежи)
    - [Аннотация типов](#Аннотация-типов)
    - [Итератор](#итератор)
    - [Генератор](#генератор)
        - [yield](#yield)
    - [Тернарный оператор](#тернарный-оператор)
    - [Лямбда функция](#лямбда-функция)
    - [Декоратор](#декоратор)
    - [args,kwargs](#argskwargs)
    - [with](#with)
- [Modules](#modules)
	- [black](#black)
	- [flake8](#flake8)
    - [count](#count)
    - [find](#find)
    - [join](#join)
	- [os](#os)
    - [re](#re)
    - [pip](#pip)
    - [type](#type)
- [Работа с виртуальным окружением](#работа-с-виртуальным-окружением)
- [Работа с файлами](#работа-с-файлами)
- [allure](#allure)
- [assert](#assert)
- [random](#random)
- [Встроенные функции](#встроенные-функции)
    - [in](#in)
    - [filter](#filter)
    - [map](#map)
    - [min, max, sum](#min-max-sum)
    - [sorted](#sorted)
    - [range](#range)
    - [pickle](#pickle)
- [классы](#классы)
	- [Наследование](#наследование)
    - [Инкапсуляция](#инкапсуляция)
	- [Полиморфизм](#полиморфизм)
    - [Абстракция](#абстракция)
	    - [@abstractmethod](#abstractmethod)
	- [@dataclass](#dataclass)
	- [@staticmethod](#staticmethod)
    - [@Встроенные свойства](#Встроенные-свойства)
    - [@Магические методы](#Магические-методы)

# Install
```python
apt install python3 # Установка Python в linux
```

```python
#!/usr/bin/python3  -строка в файле линукс, которая позволяет интерпретировать файл как python файл
```
# Теория
## Какие бывают типы данных
В Python существует два основных типа данных: 
1. Изменяемые — это те, которые можно изменять после их создания. Это значит, что вы можете изменять содержимое объекта без создания нового объекта (списки, словари, множества).
2. Неизменяемые — это те, которые нельзя изменить после их создания (числа, строки, кортежи).


В Python существует несколько основных типов данных, каждый из которых обладает своими особенностями и применяется в разных ситуациях. 
1. Числовые типы (Numeric types):
    - int — целые числа (например, 1, 2, -5).
    - float — числа с плавающей запятой (например, 3.14, -0.001).
    - complex — комплексные числа (например, 1 + 2j).
2. Строки (String):
    - str — это последовательность символов, заключенная в одинарные или двойные кавычки (например, "hello", 'world').
3. Логический тип (Boolean):
    - bool — принимает значения True или False.
4. Списки (List):
    - list — упорядоченные, изменяемые коллекции, которые могут содержать элементы разных типов (например, [1, 2, 3], ['apple', 'banana']).
5. Кортежи (Tuple):
    - tuple — упорядоченные, неизменяемые коллекции, которые также могут содержать элементы разных типов (например, (1, 2, 3), ('apple', 'banana')).
6. Множества (Set):
    - set — неупорядоченные коллекции уникальных элементов (например, {1, 2, 3})
7. Словари (Dictionary):
    - dict — Неупорядоченные коллекции пар “ключ-значение”, где ключи должны быть уникальными (например, {'name': 'Alice', 'age': 25}).
8. NoneType:
    - None — специальный тип, представляющий отсутствие значения или null.

### Списки
#### Срезы
Срезы в Python — это мощный инструмент, который позволяет извлекать подмножества последовательностей, таких как списки, строки или кортежи. Срезы определяются с помощью следующего синтаксиса
`sequence[start:end:step]`
- `start`: Индекс, с которого начинается срез (включительно). Если этот параметр пропущен, срез начнется с 0.
- `end`: Индекс, на котором срез заканчивается (исключительно). Если пропущен, срез будет продолжаться до конца последовательности.
- `step`: Шаг, с которым берутся элементы. По умолчанию равен 1. Если указать отрицательное значение, это значит, что срез будет взят в обратном порядке.
1. Основной срез:
```python
my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  
print(my_list[2:5])  # Вывод: [2, 3, 4]
```

2. Срез с указанным шагом:
```python
print(my_list[0:10:2])  # Вывод: [0, 2, 4, 6, 8]
```

3. Отрицательные индексы:
```python
print(my_list[-5:-1])  # Вывод: [5, 6, 7, 8]
```

4. Срезы с отрицательным шагом:
```python
print(my_list[::-1])  # Вывод: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

5. Пропуск параметров:
```python
print(my_list[:5])    # Вывод: [0, 1, 2, 3, 4] (с 0 до 5)  
print(my_list[5:])    # Вывод: [5, 6, 7, 8, 9] (с 5 до конца)
```

### Строки
Основные методы для работы со строками
- `str.lower()`
    - Приводит строку к нижнему регистру.
    - Пример: "Hello".lower() → "hello"

- `str.upper()`
    - Приводит строку к верхнему регистру.
    - Пример: "Hello".upper() → "HELLO"

- `str.title()`
    - Приводит первую букву каждого слова к верхнему регистру.
    - Пример: "hello world".title() → "Hello World"

- `str.strip()`
    - Удаляет пробелы в начале и конце строки.
    - Пример: " Hello ".strip() → "Hello"

- `str.replace(old, new)`
    - Заменяет подстроку old на new.
    - Пример: "Hello, world".replace("world", "Python") → "Hello, Python"

- `str.split(separator)`
    - Разделяет строку по указанному разделителю и возвращает список.
    - Пример: "a,b,c".split(",") → ["a", "b", "c"]

- `str.join(iterable)`
    - Объединяет элементы из итерируемого объекта (например, списка) в строку с указанным разделителем.
    - Пример: ",".join(["a", "b", "c"]) → "a,b,c"

- `str.find(sub)`
    - Возвращает индекс первого вхождения подстроки sub. Если не найдено, возвращает -1.
    - Пример: "Hello".find("e") → 1

- `str.count(sub)`
    - Возвращает количество вхождений подстроки sub в строке.
    - Пример: "banana".count("a") → 3

- `str.startswith(prefix)`
    - Проверяет, начинается ли строка с указанного префикса. Возвращает True или False.
    - Пример: "Hello".startswith("He") → True

- `str.endswith(suffix)`
    - Проверяет, заканчивается ли строка на указанный суффикс. Возвращает True или False.
    - Пример: "Hello".endswith("lo") → True

- `str.capitalize()`
    - Приводит первую букву строки к верхнему регистру, а остальные — к нижнему.
    - Пример: "hello world".capitalize() → "Hello world"

- `str.isdigit()`
    - Проверяет, состоит ли строка только из цифр.
    - Пример: "123".isdigit() → True

- `str.isalpha()`
    - Проверяет, состоит ли строка только из букв.
    - Пример: "abc".isalpha() → True

- `str.isalnum()`
    - Проверяет, состоит ли строка только из букв и цифр.
    - Пример: "abc123".isalnum() → True


### Словари
#### Метод del
Оператор del можно использовать для удаления ключа и значения из словаря. Он не возвращает значение и вызовет исключение KeyError, если ключ не найден.
```python
# Удалим ключ "price" из вложенного словаря "data"  
del payload["data"]["price"]  
print(payload)  # Ключ "price" удален из "data" 
```

### Кортежи
- Кортеж (tuple): Неизменяемый тип данных. После создания кортежа вы не можете изменять его содержимое.
- Кортеж (tuple): Создается с использованием круглых скобок ().
- Кортеж (tuple): Используется, когда вам нужна неизменяемая последовательность элементов, например, для представления фиксированных наборов данных

#### Методы:
Важно помнить, что ни один из методов или операций не изменяет исходный кортеж. Они всегда возвращают новый кортеж или какое-либо значение (например, число в случае count и index).
- `count(value)`: Возвращает количество раз, которое указанное значение появляется в кортеже
```python
my_tuple = (1, 2, 2, 3, 2)  
count_of_2 = my_tuple.count(2)  
print(count_of_2)  # Вывод: 3
```

- `index(value, start, end):` Возвращает индекс первого вхождения указанного значения. Если значение не найдено, вызывается исключение ValueError. start и end (необязательные параметры) позволяют указать диапазон для поиска.
```python
my_tuple = (10, 20, 30, 20)  
index_of_20 = my_tuple.index(20)  
print(index_of_20)  # Вывод: 1  

index_of_20_from_2 = my_tuple.index(20, 2)  # Начать поиск с индекса 2  
print(index_of_20_from_2)  # Вывод: 3 
```

Кроме этих методов, над кортежами можно выполнять операции, которые не изменяют сам кортеж, а возвращают новый результат:
- Сложение кортежей (+): Создает новый кортеж, объединяя два существующих.
```python
tuple1 = (1, 2, 3)  
tuple2 = (4, 5, 6)  
combined_tuple = tuple1 + tuple2  
print(combined_tuple)  # Вывод: (1, 2, 3, 4, 5, 6)  
```

- Умножение кортежа на число (*): Создает новый кортеж, повторяя исходный кортеж указанное количество раз.
```python
my_tuple = (1, 2)  
repeated_tuple = my_tuple * 3  
print(repeated_tuple)  # Вывод: (1, 2, 1, 2, 1, 2)  
```

- Получение среза ([:]): Позволяет получить часть кортежа, создавая новый кортеж.
```python
my_tuple = (1, 2, 3, 4, 5)  
slice_tuple = my_tuple[1:4]  
print(slice_tuple)  # Вывод: (2, 3, 4)  
```

## Аннотация типов
Аннотация типов в Python позволяет разработчикам указывать типы переменных, аргументов функций и возвращаемых значений, что улучшает читаемость кода и помогает инструментам статического анализа выявлять ошибки. Аннотации типов в Python не влияют на выполнение программы, но они помогают улучшить документацию и интеграцию с инструментами разработки. 

Вот пример использования аннотаций типов:
```python
def add(a: int, b: int) -> int | None:  
    return a + b  

result = add(5, 3)  
print(result)  # Вывод: 8
```
**Пояснение примера:**
- `a: int и b: int` — это аннотации типов для аргументов функции add, указывающие, что оба аргумента должны быть целыми числами.
- `-> int | None` — аннотация типа для возвращаемого значения, указывающая, что функция возвращает целое число или None (что может означать отсутствие результата или ошибку).

**Другие примеры:**

Список строк
```python
from typing import List  

def join_strings(strings: List[str]) -> str:  
    return ', '.join(strings)  

result = join_strings(['hello', 'world'])  
print(result)  # Вывод: hello, world  
```

Использование аннтоации типов при инициализации классов:
```python
class Person:  
    def __init__(self, name: str, age: int) -> None:  
        self.name: str = name  
        self.age: int = age  

    def greet(self) -> str:  
        return f"Привет, меня зовут {self.name} и мне {self.age} лет."
```

Использование типов для словарей
```python
from typing import Dict  

def get_age(name: str, ages: Dict[str, int]) -> int:  
    return ages.get(name, 0)  

ages = {'Alice': 30, 'Bob': 25}  
print(get_age('Alice', ages))  # Вывод: 30  
```

## Итератор
**Итерируемые объекты** — это объекты, которые могут быть перебраны. Примеры: списки (list), кортежи (tuple), множества (set), словари (dict) и строки (str). Они поддерживают метод `__iter__()`, который возвращает итератор.

**Итератор в Python** — это объект, который позволяет перебирать элементы коллекции (например, списка, кортежа, множества или словаря) по одному за раз. Итератор предоставляет доступ к элементам и "запоминает" свое текущее состояние. Например, он помнит, на каком элементе он остановился. Итераторы реализуют два метода:
- `__iter__()` — возвращает сам итератор. Он может возвращать объект, который имплементирует метод `__next__()`. Обычно для итерируемых объектов этот метод просто возвращает `self`.
- `__next__()` — возвращает следующий элемент последовательности из итератора. Когда элементы заканчиваются, он вызывает исключение `StopIteration`. Чтобы избежать этого, можно передать второй аргумент, который будет возвращен в случае исчерпания итератора.

**Использование встроенных итераторов**
Итерируемые объекты (такие как списки, кортежи или строки) могут создавать итераторы с помощью функции iter(). Например:

```python
my_list = [1, 2, 3]  
iterator = iter(my_list)  

print(next(iterator))  # Вывод: 1  
print(next(iterator))  # Вывод: 2  
print(next(iterator))  # Вывод: 3  
# next(iterator) вызовет StopIteration, так как элементы закончились 
print(next(iterator, "Конец"))
```

**Итерация через for-цикл**

Наиболее распространенный способ перебора элементов — это использование цикла for, который автоматически управляет итерацией и обработкой исключения StopIteration:
```python
for item in my_list:  
    print(item)  
```
Пример реализации собственного итератора. Вот пример, как создать свой собственный итератор, который перебирает числа от 1 до N:
```python
class MyIterator:  
    def __init__(self, n):  
        self.n = n  
        self.current = 1  # Начальное значение  

    def __iter__(self):  
        return self  # Возвращаем сам итератор  

    def __next__(self):  
        if self.current > self.n:  
            raise StopIteration  # Если достигли конца, выбрасываем исключение  
        else:  
            current_value = self.current  
            self.current += 1  # Увеличиваем текущее значение на 1  
            return current_value  # Возвращаем текущее значение  

# Использование итератора  
for num in MyIterator(5):  
    print(num)  

>>> 1  
>>> 2
>>> 3  
>>> 4  
>>> 5  
```

## Генератор
Генератор в Python — это специальный тип итератора, который позволяет создавать последовательности значений. Он позволяет вам генерировать значения "на лету", что экономит память, так как не нужно хранить всю последовательность в памяти сразу.

Генераторы создаются с помощью функций, использующих yield вместо return. Когда функция с yield вызывается, она возвращает объект-генератор и при этом сохраняет своё состояние, позволяя возобновить выполнение функции с того места, где она была остановлена.

Пример:
```python
def get_list():
    for x in [1, 2, 3, 4]:
        yield x

a = get_list()
print(a)            >>> <generator object get_list at 0x000001C65052CB80>
print(next(a))      >>> 1
print(next(a))      >>> 2
print(next(a))      >>> 3
print(next(a))      >>> 4
```


```python
def count_up_to(max):  
    count = 1  
    while count <= max:  
        yield count  
        count += 1

for number in count_up_to(5):  
    print(number)  
```
Этот код выведет числа от 1 до 5. Генераторы полезны для работы с большими объемами данных, когда нужно генерировать данные по мере их необходимости, а не держать их все в памяти.

1. Генерация последовательностей
Генераторы могут использоваться для создания простых последовательностей. Например, вот генератор, который создаёт последовательность квадратов чисел:
```python
def square_numbers(n):  
    for i in range(n):  
        yield i ** 2  

# Пример использования  
for square in square_numbers(5):  
    print(square)  
```

2. Генераторы для работы с файлами
Генераторы удобны для построчной обработки файлов, что позволяет обрабатывать большие файлы, не загружая их целиком в память:
```python
def read_file_line_by_line(file_path):  
    with open(file_path) as file:  
        for line in file:  
            yield line.strip()  # Удаляем символы новой строки  

# Пример использования  
for line in read_file_line_by_line('example.txt'):  
    print(line)  
```

3. Фильтрация данных
Генераторы можно использовать для фильтрации данных. Допустим, у вас есть список чисел, и вы хотите оставить только четные:
```python
def even_numbers(numbers):  
    for number in numbers:  
        if number % 2 == 0:  
            yield number  

# Пример использования  
numbers = range(10)  
for even in even_numbers(numbers):  
    print(even)  
```

4. Генераторы в комбинации с expressions (групповая генерация)
Генераторы можно создавать с помощью выражений-генераторов, которые выглядят как списковые включения, но используют круглые скобки:
```python
# Генератор, создающий кубы от 0 до 9  
cubes = (x ** 3 for x in range(10))  

# Пример использования  
for cube in cubes:  
    print(cube)  
```

5. Генерация бесконечной последовательности
Генераторы также могут использоваться для создания бесконечных последовательностей. Например, следующий генератор будет бесконечно генерировать числа Фибоначчи:
```python
def fibonacci():  
    a, b = 0, 1  
    while True:  
        yield a  
        a, b = b, a + b  

# Пример использования: печатаем первые 10 чисел Фибоначчи  
fib = fibonacci()  
for _ in range(10):  
    print(next(fib))  
```

6. Генерация данных на основе условий
Генераторы могут также использоваться с условиями для создания более сложных последовательностей. Например, можно создать генератор для получения первых N чисел, которые делятся на 3 и 5:
```python
def multiples_of_3_and_5(n):  
    count = 0  
    num = 0  
    while count < n:  
        if num % 3 == 0 and num % 5 == 0:  
            yield num  
            count += 1  
        num += 1  

# Пример использования  
for number in multiples_of_3_and_5(5):  
    print(number)  
```

### выражения-генераторы для создания итераторов
Чтобы создать выражение-генератор, нужно использовать круглые скобки вместо квадратных. Вот общий синтаксис:
```python
генератор_выражение = (выражение for элемент in итерируемый_объект if условие) 

# Пример
numbers = [1, 2, 3, 4, 5, 6]  
squared_evens = (x ** 2 for x in numbers if x % 2 == 0)  

for square in squared_evens:  
    print(square)  
```

### yield
`yield` в Python — это ключевое слово, которое используется в определении функций для преобразования обычной функции в генератор. Генераторы позволяют итерироваться по последовательности значений, не создавая сразу все значения в памяти, что особенно полезно при работе с большими наборами данных или бесконечными последовательностями. В контексте автоматизации и фикстуры это разделитель между предусловий и пост условий.

Основные моменты о yield:
1. Генерация значений: Когда функция содержит оператор yield, она возвращает генератор, который можно использовать в цикле for или в любом месте, где требуется итерация.
2. Состояние функции: Функция, содержащая yield, при каждом вызове оператора yield сохраняет свое состояние (локальные переменные и текущее значение) и продолжает выполнение с этого места при следующем вызове.
3. Экономия памяти: Генераторы позволяют сэкономить память, поскольку значения создаются по мере необходимости, а не хранятся в памяти.
```python
def count_up_to(n):  
    count = 1  
    while count <= n:  
        yield count  
        count += 1  

# Использование генератора  
for number in count_up_to(5):  
    print(number)
1  
2  
3  
4  
5    
```


## Тернарный оператор
В Python тернарный оператор реализуется с помощью конструкции, известной как "условное выражение". Синтаксис выглядит следующим образом:
`значение_если_истина if условие else значение_если_ложь`
```python
age = 18  
can_vote = "Да, может голосовать" if age >= 18 else "Нет, не может голосовать"  
print(can_vote)  # Выведет: Да, может голосовать
```
Здесь, если age больше или равен 18, переменной can_vote присваивается строка "Да, может голосовать". В противном случае — строка "Нет, не может голосовать".

## Лямбда функция
Лямбда-функция в Python — это анонимная функция, которая определяется с помощью ключевого слова lambda. Она может принимать любое количество аргументов, но может содержать только одно выражение. Лямбда-функции обычно используются для создания небольших функциональных объектов без необходимости явно определять обычную функцию с использованием def.

Синтаксис лямбда-функции выглядит следующим образом:
```python
lambda аргументы: выражение

# Лямбда-функция для сложения двух чисел  
add = lambda x, y: x + y  

# Использование функции  
result = add(2, 3)  # result будет 5  
print(result)  
```
Лямбда-функции часто применяются в таких местах, как:
- В аргументах функций высшего порядка, например, map(), filter(), и sorted()
- В качестве простых обратных вызовов в GUI и других библиотеках.
```python
# Использование в filter для фильтрации четных чисел  
numbers = [1, 2, 3, 4, 5]  
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]  
```

## Декоратор
Декоратор в Python — это специальная конструкция, позволяющая изменять или расширять поведение функции или метода без изменения их исходного кода. Это достигается с помощью функции, которая принимает другую функцию в качестве аргумента и возвращает новую функцию, обычно с добавленным функционалом.

Пример простого декоратора:
```python
def my_decorator(func):  
    def wrapper():  
        print("Перед вызовом функции.")  
        func()  
        print("После вызова функции.")  
    return wrapper  

@my_decorator  
def say_hello():  
    print("Привет!")  

say_hello()

>>> Перед вызовом функции.  
>>> Привет!  
>>> После вызова функции.  
```

```python
# Пример использования с аргументами
def decorator_1(func):
    def wrapper(*args):
        print("start decorator_1")
        func(*args)
        print("end decorator_1")
    return wrapper

@decorator_1
def any_func(a, b):
    print(f"any_func a={a}, b={b}")


any_func(1, 2)
```
Как это работает:
1. Определение декоратора: my_decorator определяет вложенную функцию wrapper, которая добавляет дополнительные действия до и после вызова оригинальной функции func.
2. Использование: С помощью @my_decorator мы "оборачиваем" функцию say_hello, что означает, что при вызове say_hello() фактически будет вызвана функция wrapper.

Декораторы часто используются для:
1. Логирования (Logging)
2. Проверки прав доступа (Authorization)
3. Кэширования (Caching)
4. Измерения времени выполнения функции (Timing)

## args,kwargs
В Python *args и **kwargs используются для передачи переменного количества аргументов в функции. Это позволяет писать более гибкие функции, которые могут принимать множество параметров.

**Пример использования *args**
*args позволяет передавать множество позиционных аргументов. Они собираются в кортеж.
```python
def print_numbers(*args):  
    for number in args:  
        print(number)  

print_numbers(1, 2, 3, 4, 5)  # Вывод: 1 2 3 4 5  
```

**Пример использования **kwargs**
**kwargs позволяет передавать множество именованных аргументов, которые собираются в словарь.
```python
def describe_pet(**kwargs):  
    for key, value in kwargs.items():  
        print(f"{key}: {value}")  

describe_pet(name="Мирка", species="Кошка", age=3)  
# Вывод:   
# name: Мирка  
# species: Кошка  
# age: 3  
```
**Комбинирование *args и **kwargs**
Вы можете использовать оба одновременно в одной функции. Важно, чтобы *args находился перед **kwargs.
```python
def show_info(name, *args, **kwargs):  
    print(f"Имя: {name}")  
    print("Дополнительные параметры:")  
    for arg in args:  
        print(arg)  
    print("Именованные параметры:")  
    for key, value in kwargs.items():  
        print(f"{key}: {value}")  

show_info("Алексей", 30, "программист", city="Москва", hobby="музыка")  
# Вывод:  
# Имя: Алексей  
# Дополнительные параметры:  
# 30  
# программист  
# Именованные параметры:  
# city: Москва  
# hobby: музыка  
```
Эти примеры показывают, как использовать *args и **kwargs для создания гибких функций в Python. Если у вас есть дополнительные вопросы или вы хотите более подробные объяснения, дайте знать!


## with
Оператор `with ... as` в Python используется для работы с контекстными менеджерами, что позволяет управлять ресурсами, обеспечивая их правильное открытие и закрытие. Это особенно полезно при работе с файлами, сетевыми соединениями и другими ресурсами, требующими очистки (например, освобождения памяти или закрытия файлов).

Конструкция `with` ... as упрощает работу с ресурсами, обеспечивает их автоматическое управление и позволяет избежать утечек ресурсов, 
что делает ваш код более чистым и безопасным.

Когда вы используете конструкцию with, она гарантирует правильное выполнение действий при входе и выходе из блока кода, даже если в нем возникает ошибка. Основными преимуществами являются:
- Автоматическое управление ресурсами.
- Упрощение синтаксиса и улучшение читаемости кода.

```python
with open('example.txt', 'w') as file:  
    file.write('Привет, мир!')  
```
1. open('example.txt', 'w'): Функция open открывает файл example.txt в режиме записи.
2. as file: Открытый файл присваивается переменной file, и теперь мы можем использовать её для записи в файл.
3. with: Когда блок кода завершен (либо нормально, либо с исключением), файл автоматически закрывается, что устраняет необходимость явно вызывать file.close().


**Основные преимущества использования with:**
- `Автоматическое управление ресурсами`: При использовании with ресурсы автоматически освобождаются после выхода из блока, даже если возникает ошибка. Например, при работе с файлами, файл будет закрыт автоматически.
- `Упрощение кода`: Код становится более читабельным и понятным, так как исключается необходимость писать явные вызовы для освобождения ресурсов.

# Modules
## black
black - форматтер для Python, который автоматически форматирует код в соответствии с PEP8 и делает его однородным. Black применяет строгий подход: не требует настроек и автоматически форматирует код по своим правилам.
```python
pip install black # запуска форматтера
> black 
> "black .\livecoding_tasks\_example_2.py"  # форматирование конкретного файла
```
## flake8
Flake8 — это линтер для Python, который проверяет код на наличие синтаксических ошибок, стиля и потенциальных багов.
```python
pip install flake8 # установка линтера flake8 для программ на Python с открытыми исходными кодами, позволяет находить ошибки в стиле оформления кода
flake8 programm.py # применить линтер к выбранному файлу
flake8 project_folder # применить линтер к всему проекту
```

## id
В Python, чтобы увидеть адрес ячейки памяти, в которой хранится переменная, можно использовать встроенную функцию id(). Эта функция возвращает уникальный идентификатор объекта, который, в большинстве реализаций Python, соответствует адресу памяти объекта.
```python
a_1 = [1, 2]
a_2 = [1, 2]
id(a_1)
>>> 1899355888896

id(a_2)
>>> 1899355886784

b_1 = 3
b_2 = 3

id(b_1)
>>> 140718421375480

id(b_2)
>>> 140718421375480
```

## count()
Функция count() в Python используется для подсчета количества элементов в различных коллекциях. Она может применяться к строкам, спискам и кортежам. Вот как она работает для разных объектов:

1. Строки - Для строк метод count() возвращает количество вхождений указанной подстроки.
```python
s = "hello world"  
count = s.count("o")  # Подсчитываем количество букв "o"  
print(count)  # Вывод: 2  
```

2. Списки - Для списков метод count() возвращает количество вхождений указанного элемента в списке.
```python
lst = [1, 2, 3, 2, 1]  
count = lst.count(2)  # Подсчитываем количество чисел 2  
print(count)  # Вывод: 2  
```

3. Кортежи - Аналогично спискам, метод count() для кортежей подсчитывает количество вхождений указанного элемента.
```python
tup = (1, 2, 3, 2, 1)  
count = tup.count(2)  # Подсчитываем количество чисел 2  
print(count)  # Вывод: 2  
```

4. Множества и Словари: Для множеств и словарей метод count() не используется, так как они не поддерживают подсчет элементов таким образом. Множества содержат только уникальные элементы, а в словарях ключи уникальны.

## find()
Метод find() в Python используется для поиска подстроки в строке. Однако он также применяется в контексте различных объектов, таких как строки, списки и другие. Вот основные аспекты работы метода find() для строк и списков:
1. Метод find() для строк
- Синтаксис: str.find(substring, start=0, end=len(string))
- Описание: Метод возвращает наименьший индекс, по которому подстрока substring найдена в строке. Если подстрока не найдена, возвращается -1.
- Параметры:
    - substring: подстрока, которую мы ищем.
    - start: (необязательный) начальный индекс для поиска.
    - end: (необязательный) конечный индекс для поиска.
```python
text = "Hello, world!"  
index = text.find("world")  
print(index)  # Вывод: 7  

index_not_found = text.find("Python")  
print(index_not_found)  # Вывод: -1
```

2. Метод find() для списков
В Python у списков нет метода find(), но можно использовать метод index(), который выполняет аналогичную задачу.

- Синтаксис: list.index(element, start=0, end=len(list))
- Описание: Метод возвращает первый индекс, по которому указанное значение element найдено в списке. Если элемент не найден, возникает исключение ValueError
```python
numbers = [1, 2, 3, 4, 5]  
index = numbers.index(3)  
print(index)  # Вывод: 2  

# index_not_found вызовет исключение  
# index_not_found = numbers.index(6)
```

## join()
Метод join() в Python используется для объединения элементов последовательности (например, списка или кортежа) в одну строку, используя указанный разделитель. Пример:
```python
separator.join(iterable)  
```
- separator: строка, которая будет использоваться как разделитель между элементами.
- iterable: любая последовательность (например, список, кортеж или строка), элементы которой будут объединены.

Пример со списком:
```python
words = ['Python', 'is', 'awesome']  
result = ' '.join(words)  
print(result)  # Вывод: "Python is awesome"  

words = ['2025', '01', '28']  
result = '-'.join(words)  
print(result)  # Вывод: "2025-01-28" 

chars = ['P', 'y', 't', 'h', 'o', 'n']  
result = ''.join(chars)  
print(result)  # Вывод: "Python"  
```

Пример со строками:
```python
new = '+'.join('stroka stroka')
print(new) # Вывод: "s+t+r+o+k+a+ +s+t+r+o+k+a"
```

Объединение чисел в строку:
```python
numbers = [1, 2, 3, 4]  
result = ', '.join(str(num) for num in numbers)  
print(result)  # Вывод: "1, 2, 3, 4"  
```


## os
**os** - модуль, который предоставляет интерфейс для взаимодействия с операционной системой.
- `os.getcwd()` - получить путь к папке, где находится текущий файл, аналогична команде `pwd` в линуксе
```python
import os
print(os.getcwd()) # получить путь к папке, где находится текущий файл
> C:\Users\admin\PycharmProjects\selenium\lesson_10

print(f'{os.getcwd()}\\downloads')
> C:\Users\admin\PycharmProjects\selenium\lesson_10\downloads
```

- `os.getenv(key, default=None)` - используется для получения значений переменных окружения.
    - key: строка, имя переменной окружения, значение которой вы хотите получить.
    - default: (необязательный параметр) значение, которое будет возвращено, если переменная окружения не найдена. По умолчанию это None.
```python
import os  

# Получаем значение переменной окружения "HOME"  
home_directory = os.getenv("HOME")  
print(f"Home Directory: {home_directory}")  

# Пробуем получить значение отсутствующей переменной "MY_VAR" с установкой значения по умолчанию  
my_var = os.getenv("MY_VAR", "default_value")  
print(f"MY_VAR: {my_var}")  
```

- `os.environ` - возвращает в виде словаря переменные окружения
- `os.mkdir('./dir_1')` - создает папку в месте размещению исполняемого файла
- `os.mkdir('./dir_2./dir_3')` - создает папку dir_2 в которой будет размещена папка dir_3, выдаст исключение "FileExistsError" если папка уже создана



# Versions
```python
python --version # показывает версию python
python3 --version # показывает версию python
```

# chmod a+x <имя скрипта>
	-сделать файл испольняемым для всех пользователей
	
Запуска скрипта python
ИЗ ТОЙ ДИРЕКТОРИИ, ГДЕ НАХОДИТСЯ ФАЙЛ СКРИПТА
	# ./<имя скрипта>	-С указанием интерпретатора в начале скрипта
	# /usr/bin/python3 <имя скрипта>	-Без указания интерпретатора в начале скрипта

ИЗ ДРУГОЙ ДИРЕКТОРИИ, ГДЕ НЕТ ФАЙЛА СКРИПТА
	# <полный путь к файлу скрипта>	-С указанием интерпретатора в начале скрипта
	# /usr/bin/python3 <полный путь к файлу скрипта>	-Без указания интерпретатора в начале скрипта

## pip
 - система управления пакетами или менеджера пакетов (Python Package Index)
```python
apt install python3-pip # установка pip в линуксе
pip3 --version	# проверить версию pip
pip install -r requirements.txt		# установка зависимостей
pip freeze	# просмотр зависимостей
pip freeze > requirements.txt	# все зависимости скопировать в файл requirements.txt
pip install pip-review  # Обновить всех пакетов в окружении
pip3 list -перечень всех установленных библиотек
pip help	# Справка по командам
pip search “имя пакета”	# Поиск пакета
pip show “имя пакета”	# Информация об пакете
pip install “имя пакета”	# Установка пакета
pip uninstall “имя пакета”	# Удаление пакета
pip list	# Список установленных пакетов
pip install -U	# Обновление пакета
```

## re
В python есть соответствующая модель re для работы с регулярными выражениями, которая позволяет удобно создавать и применять шаблоны регулярных выражений.
1. Основной синтаксис.
    .	один символ кроме новой строки
    \.	точка, обратный слеш \ убирает специальные символы
    \d	одна цифра
    \D	один символ, кроме цифры
    \w	один буквенный символ, включая цифры
    \W	один символ, кроме буквы и цифры
    \s	один пробельный символ, включая табуляцию и перенос строки
    \S	один непробельный символ
    \b	границы слова
    \n	новая строка
    \t	табуляция
2. Модификаторы.
    $	конец строки
    ^	начало строки
    ab|cd	соответствует ab или de.
    [ab-d]	один символ: a, b, c, d
    [^ab-d]	любой символ, кроме: a, b, c, d
    ()	извлечение элементов в скобках
    (a(bc))	извлечение элементов в скобках второго уровня
3. Повторы.
    [ab]{2}	2 непрерывных появления a или b
    [ab]{2,5}	от 2 до 5 непрерывных появления a или b
    [ab]{2,}	2 и больше непрерывных появления a или b
    +	одно или больше
    *	0 или больше
    ?	0 или 1

## type()
Функция `type()` в Python используется для получения типа объекта. Она возвращает класс, к которому принадлежит переданный объект. С помощью `type()` можно узнать, является ли объект строкой, числом, списком, словарем и так далее. Функция `type()` полезна для отладки и проверки типов данных в программе.
```python
num = 10  
print(type(num))  # <class 'int'>  

text = "Hello, world!"  
print(type(text))  # <class 'str'>  

lst = [1, 2, 3]  
print(type(lst))  # <class 'list'>  
```
Иногда `type()` можно использовать для проверки, является ли объект экземпляром определенного класса, с помощью `isinstance()`:
```python
print(isinstance(num, int))  # True  
print(isinstance(text, str))  # True  
```

#### pip3 команда опции пакет(ы)
	show		показать информацию о пакете
	search		найти пакет
	install		установить пакет
	uninstall	удалить пакет
	download	скачать пакет и зависимости (без установки)
	list		вывести список установленных пакетов


	

# poetry
Установка Windows (Powershell)
	официальная документация https://python-poetry.org/docs/#installing-with-the-official-installer
	в powershell: (Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -
	pip install poetry
	
poetry --version
	Poetry (version 1.7.1)

poetry config --list
	перечень настроек poetry

Установка зависимостей
	poetry install 	# для первичной установки
	poetry update 	# для обновления
	
poetry show --tree
	показать зависимости
	
poetry shell
	создать и активировать виртуальное окружение одной командой
	

# РАБОТА С ВИРТУАЛЬНЫМ ОКРУЖЕНИЕМ
Основное назначение виртуального окружения состоит в создании изолированной конфигурации программного обеспечения с определенным зафиксированным набором библиотек определенных версий. Это позволяет быстро повторить нужную конфигурацию и избежать проблем актуальности версий и совместимости библиотек между собой.
Существует множество утилит для создания виртуального окружения в python: 
- virtualenv, 
- venv, 
- conda, 
- poetry. 

1. **virtualenv**
    `sudo pip install python3-virtualenv` # Установка осуществляется командой
    `mkvirtualenv “имя окружения”`	Создать новое виртуальное окружение. Создается папка с именем “имя окружения”, содержащая всю необходимую для работы виртуального окружения информацию
    `workon`	Получить список окружений
    `workon “имя окружения”`	Изменить используемое виртуальное окружение
    `deactivate`	Выйти из виртуального окружения
    `rmvirtualenv “имя окружения”`	Удалить виртуальное окружение
2. **venv**
    `python3 –m venv <имя папки>`  Создать виртуальное окружение
    `source bin/activate`     активировать ВО
    `deactivate`
3. **conda**
    conda create --name “имя окружения” python=3.6
    conda activate “имя окружения”
    conda install numpy pandas
4. **poetry**
Главный файл для poetry — это pyproject.toml. Все данные о проекте должны быть записаны в нем. При установке пакетов poetry берет данные из этого файла и формирует файл с зависимостями poetry.lock (если уже есть готовый файл poetry.lock, то данные будут браться из него). Toml-файл состоит из нескольких блоков, каждый из которых имеет свои особенности
    pip install poetry
    poetry install --extras "mysql pgsql"   зависимости можно установить двумя способами
    poetry install -E mysql -E pgsql
    poetry new <название папки с проектом>  создать новый проект с помощью poetry. После чего создастся папка с названием вашего проекта, в этой папке будет лежать файл pyproject.toml.
    poetry install      Чтобы установить зависимости проекта
    poetry add numpy    Чтобы добавить новую библиотеку
    poetry remove numpy Чтобы удалить зависимость
    poetry show         Чтобы посмотреть зависимости проекта



apt install python3-venv
	-(команда линукс)установка пакета venv

python3 -m venv myenv
или
python -m venv myenv
	-создать новое окружение, где myenv имя вирутального окружения. После выполнения команды будет создана папка с именем myenv, содержащая все необходимые файлы для виртуального окружения.

python -m venv virt_name

pip install virtualenv
	установка virtualenv, требуется для python	


bin include lib lib64 pyvenv.cfg share
	-посмотреть содержимое виртуального окружения

source myenv/bin/activate
	-активация виртуального окружения. где myenv название папки среды

после активации виртуального окружения в командную строку будет добавлено имя виртуального окружения.


(myenv) user@host:~$ pip install requests
	-Эта команда установит пакет requests только в текущем виртуальном окружении.

deactivate
	-используется для удаления виртуальной среды

exit()

# Работа с файлами
### Открытие файла
Для работы с файлом нужно сначала открыть его с помощью функции open(). Вы можете указать режим, в котором хотите открыть файл:
- `r` — чтение (по умолчанию)
- `w` — запись (создаёт новый файл или перезаписывает существующий)
- `a` — добавление (добавляет данные в конец файла)
- `b` — двоичный режим
- `t` — текстовый режим (по умолчанию)

```python
file = open('example.txt', 'r')
```

### Чтение из файла
После открытия файла для чтения вы можете использовать несколько методов:
- `read(size)` — читает заданное количество байт (или весь файл, если размер не указан).
- `readline()` — читает одну строку.
- `readlines()` — читает все строки и возвращает их в виде списка.
```python
content = file.read()  
print(content)  
```

### Запись в файл
Для записи в файл можно использовать метод write():
```python
file = open('example.txt', 'w')  
file.write('Hello, world!')  
```

Чтобы добавить данные в существующий файл:
```python
file = open('example.txt', 'a')  
file.write('Appending this line.')
```

### Закрытие файла
После завершения работы необходимо закрыть файл, чтобы освободить ресурсы:
```python
file.close()  
```

### Работа с контекстным менеджером
Лучший способ работы с файлами — использовать контекстный менеджер with, который автоматически закроет файл после завершения работы:
```python
with open('example.txt', 'r') as file:  
    content = file.read()  
    print(content)  
```
Вот пример программы, которая создаёт файл, записывает в него строки и читает их:
```python
# Запись в файл  
with open('example.txt', 'w') as file:  
    file.write('Первая строка\n')  
    file.write('Вторая строка\n')  

# Чтение из файла  
with open('example.txt', 'r') as file:  
    content = file.read()  
    print(content)  
```

# allure
```python
$ pip install allure-pytest
$ py.test --alluredir=%allure_result_folder% ./tests
$ allure serve %allure_result_folder%
https://pypi.org/project/allure-pytest/
```
# Трехместное выражение if/else в Python

```python
if a < b:
    rez = a + b
else:
    rez = a - b

# общий вид if/else в одну строку
x = a if condition else b

# Выражение примера выше будет выглядеть следующим образом
rez = a + b if a < b else a - b.
```

# assert

```python
assert True, 'Print message'
> 

assert False, 'Print message'
> # assert False, 'Print message', AssertionError: Print message
```

**При выявлении несоответствии в методе assert дальнейший код не выполняется, а при положительном assert - дальнейший код выполняется, например**:
- Assert завершился AssertionError 
```python
value_1 = 3
value_2 = 5
assert value_1 == value_2, "Not equal"
print('this is code after assert method')

>>>
Traceback (most recent call last):
  File "C:\Users\dashkov\PycharmProjects\selenium_stepik_2\lesson_18\draft_3.py", line 4, in <module>
    assert value_1 == value_2, "Not equal"
AssertionError: Not equal
```

- Assert завершился без ошибок
```python
value_1 = 3
value_2 = 3
assert value_1 == value_2, "Not equal"
print('this is code after assert method')

>>>
this is code after assert method
```
# Встроенные функции
## all
В Python функция all() используется для проверки, являются ли все элементы итерируемого объекта истинными (т.е. приводятся к True) или если итерируемый объект пустой.
```python
all(iterable)  
# iterable: любой итерируемый объект (например, список, кортеж, множество, строка и т. д.).
```
Возвращаемое значение:
- `True`, если все элементы итерируемого объекта истинные или если он пустой.
- `False`, если хотя бы один из элементов является ложным (при приведении к False).

Примеры использования:
1. Все элементы истинные
```python
numbers = [1, 2, 3, 4]  
print(all(numbers))  # Вывод: True  
```

2. Есть ложный элемент
```python
numbers = [1, 2, 0, 4]  
print(all(numbers))  # Вывод: False  
```

3. Пустой итерируемый объект:
```python
empty_list = []  
print(all(empty_list))  # Вывод: True  
```

4. Часто используется для быстрой проверки условий в списках или других коллекциях. Если требуется проверить, например, все ли значения в списке больше нуля, можно сделать так:
```python
values = [5, 7, 9]  
result = all(value > 0 for value in values)  
print(result)  # Вывод: True  
```


## in
- `in` - Возвращает True если последовательность присутствует в объекте
- `not in` - Возвращает True если последовательность не присутствует в объекте
```python
ur_1 = "yandex.ru/slash_1/slash_2"
ur_2 = "yandex.ru"

print (ur_2 in ur_1)
> True
print (ur_2 not in ur_1)
> False

print (ur_1 in ur_2)
> False
print (ur_1 not in ur_2)
> True
```
Вхождение/наличие элемента в список/ кортеж/ множество
```python
>>> x = [1, 2, 3, 4, 5, 6, 7, 8]
>>> 5 in x
# True

>>> 5 not in x
# False

>>> 0 in x
# False

>>> 0 not in x
# True
```

## filter
Функция filter() в Python используется для фильтрации итерируемых объектов (таких как списки, кортежи и т.д.) по заданному условию. Она принимает два аргумента: функцию и итерируемый объект. Возвращает итератор, содержащий элементы, для которых функция вернула True.
```python
# Синтаксиc
filter(function, iterable)
```
- `function`: Функция, которая определяет условие фильтрации. Если функция возвращает True, элемент будет включен в результат; если False, элемент будет исключён.
- `iterable`: Итерируемый объект, который вы хотите отфильтровать.
Пример:
```python
# Определяем список чисел  
numbers = [1, 2, 3, 4, 5, 6]  

# Функция, которая проверяет четность  
def is_even(num):  
    return num % 2 == 0  

# Используем filter для фильтрации четных чисел  
even_numbers = filter(is_even, numbers)  

# Преобразуем результат в список  
even_numbers_list = list(even_numbers)  

print(even_numbers_list)  # Вывод: [2, 4, 6]  
```

## map
Функция `map` в Python — это встроенная функция, которая позволяет применять заданную функцию к каждому элементу переданной последовательности (например, к списку, кортежу или строке) и возвращать итератор, содержащий результаты применения функции.
- `map` возвращает итератор, поэтому для получения результата нужно преобразовать его в список или другую коллекцию, если требуется.
- Функция может быть любой callable, включая встроенные функции, пользовательские функции и лямбда-функции.
- Если передано несколько итерируемых объектов, функции, применяемой через `map`, должны быть 1:1 соответствия по количеству аргументов.

Функция `map` удобна для функционального программирования, часто используется для обработки данных и упрощает код, избегая необходимости в явных циклах.

Синтаксис
```python
map(function, iterable, ...)  
```
- **function**: функция, которая будет применена к каждому элементу. Это может быть как встроенная функция, так и пользовательская функция.
- **iterable**: одна или несколько последовательностей, к элементам которых будет применяться функция. Если передано несколько последовательностей, функция должна принимать такое же количество аргументов, сколько последовательностей.

`map` возвращает итератор, который можно преобразовать в другие структуры данных (например, в список или кортеж).

Примеры использования
1. Применение функции к каждому элементу списка:
```python
def square(x):  
    return x * x  

numbers = [1, 2, 3, 4, 5]  
squared_numbers = map(square, numbers)  

# Преобразуем в список  
print(list(squared_numbers))  # Вывод: [1, 4, 9, 16, 25]  
```
2. Использование лямбда-функции:
```python
numbers = [1, 2, 3, 4, 5]  
squared_numbers = map(lambda x: x * x, numbers)  

print(list(squared_numbers))  # Вывод: [1, 4, 9, 16, 25] 
```
3. Применение функции к нескольким итераторам:
```python
def add(x, y):  
    return x + y  

a = [1, 2, 3]  
b = [4, 5, 6]  
sum_ab = map(add, a, b)  

print(list(sum_ab))  # Вывод: [5, 7, 9]  
```

## min, max, sum
1. min()
Функция min() возвращает наименьшее значение среди переданных аргументов. Она может работать с несколькими аргументами или с последовательностью (например, списком).
```python
# С несколькими аргументами  
print(min(3, 5, 2, 8))  # Вывод: 2  

# С последовательностью  
numbers = [3, 5, 2, 8]  
print(min(numbers))  # Вывод: 2  
```
2. max()
Функция max() работает аналогично функции min(), но возвращает наибольшее значение.
```python
# С несколькими аргументами  
print(max(3, 5, 2, 8))  # Вывод: 8  

# С последовательностью  
numbers = [3, 5, 2, 8]  
print(max(numbers))  # Вывод: 8  
```

3. sum()
Функция sum() возвращает сумму элементов в последовательности. По умолчанию она принимает второй аргумент, который добавляется к сумме (по умолчанию равен 0).
```python
# Список чисел  
numbers = [1, 2, 3, 4, 5]  
print(sum(numbers))  # Вывод: 15  

# С добавлением начального значения  
print(sum(numbers, 10))  # Вывод: 25 (15 + 10)  
```

## sorted
В Python функция sorted() используется для сортировки итерируемых объектов, таких как списки, кортежи и строки. Эта функция returns a new sorted list from the elements of any iterable. 
- sorted() не изменяет оригинальный список — он возвращает новый отсортированный список.
- Если вы хотите отсортировать список "на месте", можно использовать метод sort(), который вызывается для списков.

```python
sorted(iterable, key=None, reverse=False)  
```
- iterable: объект, который нужно отсортировать (например, список, кортеж).
- key: (необязательный) функция, которая извлекает ключ для сравнения элементов (по умолчанию используется сам элемент).
- reverse: (необязательный) если True, сортировка будет в обратном порядке.

1. Сортировка списка чисел:
```python
numbers = [5, 2, 9, 1, 5, 6]  
sorted_numbers = sorted(numbers)  
print(sorted_numbers)  # Вывод: [1, 2, 5, 5, 6, 9]
```

2. Сортировка строк:
```python
words = ["banana", "apple", "cherry"]  
sorted_words = sorted(words)  
print(sorted_words)  # Вывод: ['apple', 'banana', 'cherry']  
```

3. Сортировка в обратном порядке:
```python
sorted_numbers_desc = sorted(numbers, reverse=True)  
print(sorted_numbers_desc)  # Вывод: [9, 6, 5, 5, 2, 1] 
```

4. Использование параметра key:
key позволяет определить функцию, которая будет применена к каждому элементу перед сравнением. Это дает возможность сортировать элементы не по их значению, а по какому-то другому критерию.
- Может принимать любую функцию: Вы можете использовать как встроенные функции, так и функции, определенные вами. Например, если у вас есть список строк, и вы хотите отсортировать их по длине, вы можете использовать функцию `len`.
- Возвращаемое значение функции: Функция, переданная в key, должна возвращать значение, по которому будет производиться сортировка. Это значение должно быть сравнимым (то есть у него должно быть определено поведение для операций сравнения).
```python
# Сортировка списка по длине строк  
words = ["banana", "pear", "apple", "cherry"]  
sorted_by_length = sorted(words, key=len)  
print(sorted_by_length)  # Вывод: ['pear', 'apple', 'banana', 'cherry']
```

```python
# Сортировка списка кортежей по второму элементу  
data = [(1, 'one'), (3, 'three'), (2, 'two'), (4, "four"), (5, "fife"), (6, "six")]
sorted_data = sorted(data, key=lambda x: x[1])  
print(sorted_data)  # Вывод: [(5, 'fife'), (4, 'four'), (1, 'one'), (6, 'six'), (3, 'three'), (2, 'two')]
```

5. Сортировка словаря по ключам:
```python
data = {'b': 1, 'a': 2, 'c': 3}  
sorted_keys = sorted(data)  
print(sorted_keys)  # Вывод: ['a', 'b', 'c']  
```



## range
Функция `range()` генерирует последовательность чисел. Чаще всего функция `range()` используется для создания списков либо в циклах.

```python
# Использование в циклах:
for x in range(5):
    print(x)
>>>
0
1
2
3
4
```

```python
# Базовое использование range
a_1 = range(5) # при указании одного числа последовательность начинается с 0 
a_2 = list(a_1) 

print(a_1)		> range(0, 5)
print(a_2)		> [0, 1, 2, 3, 4]
```
```python
#  Указание начального значения
a_1 = range(1, 5)
a_2 = list(a_1)

print(a_1)
print(a_2)
>>> range(1, 5)
>>> [1, 2, 3, 4]
```

```python
# Указание шага
c_1 = range(0, 50, 10)
c_2 = list(c_1)

print(c_1)		> range(0, 50, 10)
print(c_2)		> [0, 10, 20, 30, 40]
```

```python
# Отрицательный шаг
a_1 = range(10, 0, -1)
a_2 = list(a_1)

print(a_1)		range(10, 0, -1)
print(a_2)		[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```


## pickle
```python
import os
import pickle

# синтаксис pickle.dump: что, куда и операции
pickle.dump(
    driver.get_cookies(),
    open(os.getcwd()+"/cookies/cookies.pkl", "wb"))

# синтаксис pickle.load: что загружем, откудакуда и операции
cookies = pickle.load(open(os.getcwd()+"/cookies/cookies.pkl", "rb"))
```

Операции pickle:
- wb - write binary: записать в бинарном формате
- rb - read binary: считать из  бинарного формата

## random

### random.randint и random.randrange
```python
import random

""" Функции randint и randrange возвращают целое число. """
number = random.randint(1, 10) # вернет значение от 1 до 10, оба значения включены в диапазон
number = random.randrange(10) # вернет значение от 0 до 9
number = random.randrange(5,10) # вернет значение от 5 до 9
number = random.randrange(1, 102, 10) # вернет одно значение из списка [1, 11, 21, 31, 41, 51, 61, 71, 81, 91, 101]
```

### random.random
```python
""" Функции random возвращает случайное число с плавающей точкой."""
number = random.random() # возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 (но исключая 1.0)
```

### random.uniform
```python
""" Функции uniform тоже возвращает случайное число с плавающей точкой,  но при этом она позволяет задавать диапазон значений, из которого следует отбирать значения. """
number = random.uniform(1.0, 10.0) # возвращает случайное число с плавающей точкой в диапазоне от 1.0 до 10.0
```

### random.choices
```python
""" Функции choices возвращает список из n повторяющихся элементов."""
a = random.choices([1, 2, 3, 4, 5, 6, 7], k=3)
print(a)

> [3, 1, 3]
```

### random.sample
```python
""" Функции sample возвращает список из n не повторяющихся элементов."""
a = random.sample([1, 2, 3, 4, 5, 6, 7], 2)
print(a)

> [3, 1]
```

### random.seed 
"random seed" используется для инициализации генератора случайных чисел, что позволяет воспроизводить одинаковые случайные последовательности. Seed (семя) — это начальное число, которое используется генератором случайных чисел для создания последовательности случайных чисел. Если вы начинаете с одного и того же семени, вы получите одинаковую последовательность случайных чисел каждый раз.
```python
import random  

# Установим семя  
random.seed(10)  

# Теперь генерируем случайные числа  
print(random.randint(1, 100))  # Например, это может вывести 73  
print(random.randint(1, 100))  # Это может вывести 43
```
Если вы снова запустите этот код с тем же семенем (10), вы снова получите 73 и 43. Если вы измените семя:
```python
random.seed(20)  
print(random.randint(1, 100))  # Теперь это может быть, например, 56  
print(random.randint(1, 100))  # И это может быть 61  
```
- **Воспроизводимость:** Используя одно и то же семя, вы всегда получаете одни и те же случайные числа, что полезно для тестирования.
- **По умолчанию:** Если вы не устанавливаете семя, Python будет использовать текущее время или другое случайное значение, так что последовательность каждый раз будет разной.
- **При тренировках и исследованиях:** Это часто используется в научных исследованиях и алгоритмах машинного обучения, когда вам нужно контролировать вариации в ваших экспериментах.

# Классы
ООП - подход в программировании, основанной на создании объектов, которые содержат атрибуты данных и методы для работы с этими данными.

`Класс в Python` — это шаблон для создания объектов, который объединяет данные (атрибуты) и функции (методы), которые работают с этими данными. Классы позволяют создавать новые типы данных, инкапсулируя логику и состояние. Классы являются основой объектно-ориентированного программирования (ООП) в Python.

`Объект (Экземпляр класса)` - это программная сущность, которая создается на основе класса и содержит данные и методы. В концептуальном плане объект представляет собой автономную единицу, которая состоит из атрибутов данных и методов, которые оперируют атрибутами данных. 
`Атрибуты данных` - находящиеся внутри объекта данные 
`Методы` - Выполняемые объектом функции, которые выполняют операции с атрибутами данных.
`Инкапсуляция` - объединение данных и программного кода в одном объекте.

Принципы ООП в python:
1. Наследование
2. Инкапсуляция
3. Полиморфизм
4. Абстракция

## Наследование
Наследование - возможность создания нового класса на основе уже существующего, наследуя его свойства и методы. Это способствует повторному использованию кода и упрощает его поддержку.

Вот основные моменты о наследовании классов в Python:
1. Создание базового класса: Это класс, от которого будут наследоваться другие классы.
2. Создание производного класса: Это класс, который наследует свойства и методы базового класса.

```python
# Определяем базовый класс  
class Animal:  
    def __init__(self, name):  
        self.name = name  

    def speak(self):  
        return "Animal sound"  

# Определяем производный класс  
class Dog(Animal):  
    def speak(self):  
        return "Bark"  

class Cat(Animal):  
    def speak(self):  
        return "Meow"

class Cow(Animal):
    def __init__(self, name, weight):
        Animal.__init__(self, name)  # super().__init__(name)
        self.weight = weight
    def speak(self):
        return "Moo"

class 

# Создаем экземпляры производных классов  
dog = Dog("Rex")  
cat = Cat("Mittens") 
cow = Cow("Marta", 300)

# Вызываем метод speak  
print(dog.name + " says: " + dog.speak())  # Rex says: Bark  
print(cat.name + " says: " + cat.speak())  # Mittens says: Meow 
print(cow.name + " says: " + cow.speak(), "and weight is: " + str(cow.weight)  # Marta says: Moo and weight is: 300
```
### Особенности при наследовании классов 
1. Ключевое слово `super()`: Используется для вызова методов базового класса.
```python
class Dog(Animal):  
    def __init__(self, name, breed):  
        super().__init__(name)  # Вызов конструктора базового класса  
        self.breed = breed  
```
2. Множественное наследование: Класс может наследовать от нескольких классов.
```python
class Canine:  
    def bark(self):  
        return "Woof!"  

class Pet:  
    def play(self):  
        return "Playing!"  

class Dog(Canine, Pet):  
    pass 
```
3. Переопределение методов: Метод в производном классе может переопределять метод базового класса.
4. Абстрактные классы: Используются для создания интерфейсов. Для этого используется модуль abc.
```python
from abc import ABC, abstractmethod  

class Animal(ABC):  
    @abstractmethod  
    def speak(self):  
        pass  

class Dog(Animal):  
    def speak(self):  
        return "Bark"  
```

## Инкапсуляция
`Инкапсуляция` — скрытие внутренней реализации класса и предоставление только необходимых интерфейсов для взаимодействия с его объектами. Это помогает защитить внутренние данные и методы от некорректного использования, а также упрощает изменения и улучшает читаемость кода.

## Полиморфизм
Полиморфизм — Возможность использования одного и того же интерфейса для различных типов объектов. В Python полиморфизм достигается с помощью методов, которые могут иметь одинаковые имена, но разные реализации в разных классах.

Основные типы полиморфизма в Python:
- Полиморфизм через наследование: Когда дочерние классы переопределяют методы родительского класса.
- Полиморфизм через интерфейсы: Когда разные классы реализуют один и тот же метод, но ведут себя по-разному.

**Пример полиморфизма через наследование**
```python
class Animal:  
    def speak(self):  
        raise NotImplementedError("Subclasses must implement this method")  

class Dog(Animal):  
    def speak(self):  
        return "Woof!"  

class Cat(Animal):  
    def speak(self):  
        return "Meow!"  

def animal_sound(animal):  
    print(animal.speak())  

# Примеры использования  
dog = Dog()  
cat = Cat()  

animal_sound(dog)  # Вывод: Woof!  
animal_sound(cat)  # Вывод: Meow!  
```
Объяснение примера:
- В классе `Animal` определён метод `speak`, который должен быть переопределён в дочерних классах. Он вызывает ошибку, если вызывается в самом классе Animal.
- Классы `Dog` и `Cat` наследуют от `Animal` и предоставляют свою реализацию метода speak.
- Функция `animal_sound` принимает объект типа `Animal` и вызывает его метод `speak`. Благодаря полиморфизму, можно передавать объекты разных классов (`Dog` и `Cat`) и получать правильный звук.

**Пример полиморфизма через интерфейсы**
```python
class Bird:  
    def fly(self):  
        return "I'm flying!"  

class Airplane:  
    def fly(self):  
        return "Flying through the sky!"  

def fly_object(flyable):  
    print(flyable.fly())  

# Примеры использования  
sparrow = Bird()  
boeing = Airplane()  

fly_object(sparrow)  # Вывод: I'm flying!  
fly_object(boeing)   # Вывод: Flying through the sky!  
```
**Объяснение примера:**
- Класс `Bird` и класс `Airplane` оба имеют метод `fly()`.
- Функция `fly_object` принимает объект, имеющий метод `fly`, и вызывает этот метод. Таким образом, можно использовать любые объекты, которые реализуют этот метод, независимо от их внутренней структуры.

Таким образом, полиморфизм позволяет разработчикам писать более абстрактный и гибкий код, обеспечивая возможность для расширения и изменения, не влияя на существующий код.

## Абстракция
Абстракция в объектно-ориентированном программировании (ООП) в Python — это принцип, который позволяет скрыть сложные детали реализации и предоставить только необходимые интерфейсы для взаимодействия с объектами. Она помогает сосредоточиться на том, что делает объект, а не на том, как он это делает.

### @abstractmethod
Абстрактные классы в Python позволяют создавать базовые классы с определенными методами, которые должны быть реализованы в производных классах. Это полезно для определения интерфейса, который обязаны соблюдать подклассы. Для работы с абстрактными классами в Python используется модуль abc.

**Основные элементы абстрактных классов**
1. Модуль abc: Импортирует необходимые декораторы и классы для создания абстрактных классов.
2. Декоратор @abstractmethod: Используется для определения абстрактного метода, который должен быть реализован в производных классах.

```python
from abc import ABC, abstractmethod  

# Определяем абстрактный класс  
class Animal(ABC):  

    @abstractmethod  
    def speak(self):  
        pass  # Абстрактный метод без реализации  

    @abstractmethod  
    def move(self):  
        pass  # Другой абстрактный метод  

# Определяем производный класс  
class Dog(Animal):  
    
    def speak(self):  
        return "Bark"  

    def move(self):  
        return "Run"  

# Еще один производный класс  
class Bird(Animal):  

    def speak(self):  
        return "Tweet"  

    def move(self):  
        return "Fly"  

# Создаем экземпляры производных классов  
dog = Dog()  
bird = Bird()  

# Вызываем методы  
print(dog.speak())  # Output: Bark  
print(dog.move())   # Output: Run  
print(bird.speak()) # Output: Tweet  
print(bird.move())  # Output: Fly 
```
**Особенности абстрактных классов**
1. Невозможность создания экземпляра: Нельзя создать экземпляр абстрактного класса напрямую. Например, animal = Animal() вызовет ошибку TypeError.
2. Наследование: Продуктовые классы должны реализовывать все абстрактные методы базового класса, иначе они также станут абстрактными.
3. Дополнительные методы: Абстрактный класс может иметь и обычные методы с реализацией.

**Заключение**

Абстрактные классы являются мощным инструментом для обеспечения соблюдения интерфейсов в иерархиях классов. Они способствуют созданию более структурированного, поддерживаемого и понятного кода. Использование абстрактных классов помогает определить, какие методы должны быть реализованы в производных классах, что делает код более предсказуемым и удобным для понимания.

## @dataclass
```python
from dataclasses import dataclass 

@dataclass
class Card:
    summary: str = None
    owner: str = None
    state: str = "todo"
    id: int = field(default=None, compare=False)

    @classmethod
    def from_dict(cls, d):
        return Card(**d)
    def to_dict(self):
        return asdict(self)
```


## @staticmethod
`@staticmethod` в Python — это декоратор, который используется для определения статического метода внутри класса. 
Статический метод не требует доступа к экземпляру класса (то есть объекту, созданному из этого класса) или к самому классу. 
Он может быть вызван как через сам класс, так и через экземпляры класса.

Вот основные особенности статических методов:
1. Нет доступа к `self` и `cls`: Поскольку статический метод не привязан ни к экземпляру, ни к классу, он не принимает автоматически аргументы self (для экземпляра) или cls (для класса).
2. Пользовательские функции: Статические методы могут использоваться для того, чтобы группировать функции, которые логически относятся к классу, даже если они не работают с его экземплярами или атрибутами класса.
3. Вызов: Их можно вызывать как через экземпляр класса, так и через сам класс.

Пример использования:
```python
class MyClass:  
    @staticmethod
    def my_static_method(x, y):  
        return x + y  

# Вызов статического метода через класс  
result1 = MyClass.my_static_method(5, 3)  
print(result1)  # Вывод: 8  

# Вызов статического метода через экземпляр класса  
obj = MyClass()  
result2 = obj.my_static_method(10, 20)  
print(result2)  # Вывод: 30  
```

Пример использования из проекта:
```python
class Common:

	@staticmethod
	def skip_if_eng_lang_and_fca_license(cur_language, cur_country):
		if cur_country == "gb" and cur_language == "":
			pytest.skip("Current test case not available for the Eng language and FCA license")
```


## Встроенные свойства
- `__dict__` - возвращает словарь, в котором все свойства класса или объекта.
- `Point.type_pt = "disc"` - добавление нового свойства `type_pt` со значением `disc` для класса. для всех объектов также появится это свойство.
- `setattr(Point, 'prop', 1)` - добавление нового свойства `prop` со значением `1` для класса. если же прописать уже существующий атрибут, то он будет переопределен: `setattr(Point, 'prop', 2)`
- `getattr(Point, 'a')` - если в классе нет атрибута а, то вызывет ошибку
- `getattr(Point, 'a', False)` - если в классе нет атрибута а, то вызывет False
- `getattr(Point, 'color')` - вернет "black"
- `hesattr(Point, 'prop')` - если такого атрибута нет, то вернет False, если атрибут существует то вернет True
- `delattr(Point, 'type_pt')` - удаляет атрибут из класса, если вызывем для несуществующего атрибута то появится ошибка 

## Магические методы
- `__init__(self)` - инициализатор объекта класса, вызывается сразу после создания экземпляра класса
- `__del__(self)` - финилизатор класса, вызывается непосредственно перед его удалением


# @contextmanager
В Python @contextmanager — это декоратор из модуля contextlib, который позволяет создавать контекстные менеджеры без необходимости реализовывать методы __enter__ и __exit__ в классе. Контекстные менеджеры используются в конструкции with для автоматического управления ресурсами, такими как файлы или сетевые соединения, обеспечивая их корректное открытие и закрытие.

Когда вы используете @contextmanager, вы можете определить yield в функции, что позволяет разделить код на две части: до yield и после. Код до yield выполняется при входе в контекст, а код после yield выполняется при выходе из контекста, что позволяет обрабатывать освобождение ресурсов.

Вот пример использования @contextmanager:
```python
 print("Entering the context")  
 try:  
 yield42 # Значение, которое будет возвращено в блоке with finally:  
 print("Exiting the context")  

# Используем контекстный менеджерwith my_context_manager() as value:  
 print(f"Inside the context: {value}")  
```

Вывод будет следующим:
```python
Entering the contextInside the context:42Exiting the context```  

В этом примере при входе в контекст выполняется код перед `yield`, при выходе — код после `yield`. Это удобно для управления ресурсами и обеспечения их правильного освобождения.  
```

пример
```python
@contextmanager
def cards_db():
    db_path = get_path()
    db = cards.CardsDB(db_path)
    yield db
    db.close()
```

`list_1 = [1, 2, 3, 4, 5]`

`list_1[::-1]`      `[5, 4, 3, 2, 1]`