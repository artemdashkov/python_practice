Действия с массивами
=============Изменение формы массива=============
Создадим массив из восьми чисел:
import numpy as np
arr = np.arange(8)
arr
# array([0, 1, 2, 3, 4, 5, 6, 7])

Поменять форму массива arr можно с помощью присвоения атрибуту shape кортежа с желаемой формой. Как и принято в NumPy, первое число задало число строк, а второе — число столбцов. Присвоение нового значения атрибуту shape изменяет тот массив, с которым производится действие.

arr.shape = (2, 4)
arr
# array([[0, 1, 2, 3],
#        [4, 5, 6, 7]])

Чтобы оставить исходный массив без изменений и дополнительно получить новый массив новой формы, нужно использовать функцию reshape. Она также принимает в качестве аргумента кортеж из чисел для формы, но возвращает новый массив, а не изменяет исходный:

arr = np.arange(8)
arr_new = arr.reshape((2, 4))
arr_new
# array([[0, 1, 2, 3],
#       [4, 5, 6, 7]])

У функции reshape есть дополнительный именованный аргумент order. Он задаёт принцип, по которому элементы заполняют массив новой формы. Если order='C' (по умолчанию), массив заполняется по строкам, как в примере выше. Если order='F', массив заполняется числами по столбцам:

arr = np.arange(8)
arr_new = arr.reshape((2, 4), order='F')
arr_new
# array([[0, 2, 4, 6],
#       [1, 3, 5, 7]])

Ещё одной часто используемой операцией с формой массива (особенно двумерного) является транспонирование. Эта операция меняет строки и столбцы массива местами. В NumPy эту операцию совершает функция transpose.

Будем работать с двумерным массивом:

arr = np.arange(8)
arr.shape = (2, 4)
arr
# array([[0, 1, 2, 3],
#        [4, 5, 6, 7]])

Транспонируем его:

arr_trans = arr.transpose()
arr_trans
# array([[0, 4],
#        [1, 5],
#        [2, 6],
#        [3, 7]])

При транспонировании одномерного массива его форма не меняется:

arr = np.arange(3)
print(arr.shape)
# (3,)
arr_trans = arr.transpose()
print(arr_trans.shape)
# (3,)

=============Индексы и срезы в массивах=============
Создадим массив из шести чисел:

arr = np.linspace(1, 2, 6)
arr
# array([1. , 1.2, 1.4, 1.6, 1.8, 2. ])

Обратиться к его элементу по индексу можно так же, как и к списку:
print(arr[2])
# 1.4

Привычная запись для срезов работает и для одномерных массивов:
print(arr[2:4])
# [1.4 1.6]

Наконец, напечатать массив в обратном порядке можно с помощью привычной конструкции [::-1]:
print(arr[::-1])
# [2.  1.8 1.6 1.4 1.2 1. ]

С многомерными массивами работать немного интереснее. Создадим двумерный массив из одномерного:
nd_array =  np.linspace(0, 6, 12, endpoint=False).reshape(3,4)
nd_array
# array([[0. , 0.5, 1. , 1.5],
#        [2. , 2.5, 3. , 3.5],
#        [4. , 4.5, 5. , 5.5]])

Для индексации по массиву в NumPy достаточно в одних и тех же квадратных скобках перечислить индексы через запятую. Вот так:
nd_array[1, 2]
# 3.0

Через запятую можно передавать срезы или даже их комбинации с индексами. Например, получим все элементы из колонки 3 для первых двух строк:

nd_array[:2, 2]
# array([1., 3.])

Несмотря на то что в массиве этот срез является столбцом, вместо него мы получили одномерный массив в виде строки.

Можно применять срезы сразу и к строкам, и к столбцам:

nd_array[1:, 2:4]
# array([[3. , 3.5],
#       [5. , 5.5]])

Чтобы получить все значения из какой-то оси, можно оставить на её месте двоеточие. Например, из всех строк получим срез с третьего по четвёртый столбцы:
nd_array[:, 2:4]
# array([[1. , 1.5],
#       [3. , 3.5],
#       [5. , 5.5]])

Чтобы получить самую последнюю ось (в данном случае все столбцы), двоеточие писать необязательно. Строки будут получены целиком по умолчанию:
nd_array[:2]
# array([[0. , 0.5, 1. , 1.5],
#       [2. , 2.5, 3. , 3.5]])