========МАССИВЫ========
Массив в программировании — это ещё одна структура данных. Она позволяет хранить элементы в заданном порядке точно так же, как это делают списки. 

Однако массивы обладают особым свойством: элемент по любому номеру из массива можно получить за одно и то же время. Другими словами, неважно, находится элемент в начале, в середине или в конце списка — на времени получения элемента из массива по индексу (номеру) это никак не скажется.

Итак, массив — это структура данных, в которой:
1. Элементы хранятся в указанном порядке.
2. Каждый элемент можно получить по индексу за одинаковое время.
3. Все элементы приведены к одному и тому же типу данных.
4. Максимальное число элементов и объём выделенной памяти заданы заранее.

Размерностью массива называют то число индексов, которое необходимо для однозначного получения элемента из массива.
- Соответственно, чтобы найти элемент в массиве размерности 1 (строка из чисел) достаточно одного индекса.
- В двумерном массиве (таблице из чисел) потребуется уже два индекса: номер строки и номер столбца.
- Для трёхмерного массива (например, контейнеры на судне расположены по длине, ширине и высоте судна) потребуется уже три индекса.

Форма (структура) массива — это информация о количестве размерностей массива и протяжённости массива по каждой из размерностей. Например, можно задать двумерный массив размера 3x5 — у этой таблицы две размерности: 3 строки и 5 столбцов.

========Создание массивов========
Создание массива из списка
arr = np.array([1,5,2,9,10])
arr = np.array([1, 2, 3])
print(arr)

[1 2 3]

Функция np.array возвращает объекты типа numpy.ndarray. Название ndarray — это сокращение от n-dimensional array, n-мерный массив.
print(type(arr))
<class 'numpy.ndarray'>

Двумерный массив из списка списков.
arr = np.array([[1, 2, 3],
                [4, 5, 6]])
print(arr)
print(type(arr))
[[1 2 3]
 [4 5 6]]

========Типы данных в массиве========
Узнать это можно, напечатав свойство dtype:
arr = np.array([1,5,2,9,10])
print(arr.dtype)

# int32

Задать тип данных сразу при создании массива можно с помощью параметра dtype:
arr = np.array([1,5,2,9,10], dtype=np.int8)
print(arr)
print(arr.dtype)

# [ 1  5  2  9 10]
# int8

Теперь, если добавить в arr число больше 127 или меньше -128, оно потеряет исходное значение, как и при преобразовании к меньшему типу:
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr[0] = 128
print(arr)
# [-128    5    2    9   10]

Если добавить float в массив int, пропадёт десятичная часть:
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr[0] = 2.5
print(arr)
# [ 2  5  2  9 10]

Строку, которую можно преобразовать в число, можно сразу положить в массив. Она будет приведена к нужному типу автоматически:
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr[0] = "3"
print(arr)

# [ 3  5  2  9 10]

А вот при попытке положить в массив строку, которую нельзя преобразовать в число, возникнет ошибка:
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr[0] = "test"
print(arr)

ValueError: invalid literal for int() with base 10: 'test'


Поменять тип данных во всём массиве можно с помощью тех же функций, которыми мы пользовались для преобразования типов отдельных переменных в предыдущем юните (например, np.int32 или np.float128):
arr = np.array([1,5,2,9,10], dtype=np.int8)
arr = np.float16(arr)
print(arr)
print(arr.dtype)

# [ 1.  5.  2.  9. 10.]
# float16

При преобразовании типов данных в массиве не забывайте о том, что часть чисел может потерять смысл, если менять тип данных с более ёмкого на менее ёмкий:
arr = np.array([1,-5,2,9,10], dtype=np.int8)
print(arr)
arr = np.uint8(arr)
print(arr)

# [ 1 -5  2  9 10]
# [  1 251   2   9  10]

========Свойства NumPy-массивов========
Узнать размерность массива можно с помощью .ndim:
arr_1 = np.array([1,-5,2,9,10], dtype=np.int8)
arr_2 = np.array([[1,2,3],
                  [4,5,6]], dtype=np.int16)
				  
print(arr_1.ndim)
print(arr_2.ndim)

# 1
# 2

Узнать общее число элементов в массиве можно с помощью .size:
arr_1 = np.array([1,2,3,4], dtype=np.int8)
arr_2 = np.array([[1,2,3],
                  [4,5,6]], dtype=np.int16)

print(arr_1.size)
print(arr_2.size)

# 4
# 6

Форма или структура массива хранится в атрибуте .shape. Форма массива хранится в виде кортежа с числом элементов, равным размерности массива. Соответственно, для одномерного массива напечатан кортеж длины 1. Обратите внимание, что для двумерного массива вначале было напечатано число «строк», а затем число «столбцов». Это так только отчасти. На самом деле массив как бы состоит из внешних и внутренних массивов: вспомните, что мы передавали список, состоящий из трёх списков, длина каждого из которых равнялась трём. Форма массива определяется от длины внешнего массива (3) к внутреннему (3).
print(arr_1.shape)
print(arr_2.shape)

(4,)
(2, 3)

Наконец, узнать, сколько «весит» каждый элемент массива в байтах позволяет .itemsize:
print(arr_1.itemsize)
print(arr_2.itemsize)

# 1
# 2

========Заполнение новых массивов========
Не всегда значения, которые будут храниться в массиве, уже доступны, а иметь для них массив уже хочется. Можно заранее подготовить массив заданной размерности, заполненный нулями, а потом загружать в него реальные данные по мере необходимости.

Массив из нулей создаётся функцией np.zeros. Она принимает аргументы shape (обязательный) — форма массива (одно число или кортеж) и dtype (необязательный) — тип данных, который будет храниться в массиве.

Создадим одномерный массив из пяти элементов:
arr_5 = np.zeros(5)
print(arr_5)

# [0. 0. 0. 0. 0.]

Создадим трёхмерный массив с формой 5x4x3 и типом float32:
arr_3d = np.zeros((2, 3, 4), dtype=np.float32)
print(arr_3d)

[[[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]]
  
===========
Ещё одной удобной функцией для создания одномерных массивов является arange. Она аналогична встроенной функции range, но обладает рядом особенностей. Вот её сигнатура: arange([start,] stop, [step,], dtype=None).

Аргументы start (по умолчанию 0), step (по умолчанию 1) и dtype (определяется автоматически) являются необязательными:

- start (входит в диапазон возвращаемых значений) задаёт начальное число;
- stop (не входит в диапазон возвращаемых значений, как и при использовании range) задаёт правую границу диапазона;
- step задаёт шаг, с которым в массив добавляются новые значения.
В отличие от range, в функции arange все перечисленные параметры могут иметь тип float.

Создадим массив из пяти чисел от 0 до 4:
np.arange(5)
# array([0, 1, 2, 3, 4])

Создадим массив от 2.5 до 5:
np.arange(2.5, 5)
# array([2.5, 3.5, 4.5])

Создадим массив от 2.5 до 5 с шагом 0.5:
np.arange(2.5, 5, 0.5)
# array([2.5, 3. , 3.5, 4. , 4.5])

Создадим массив от 2.5 до 5 с шагом 0.5 и с типом float16:
np.arange(2.5, 5, 0.5, dtype=np.float16)
# array([2.5, 3. , 3.5, 4. , 4.5], dtype=float16)